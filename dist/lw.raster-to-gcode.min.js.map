{"version":3,"sources":["webpack:///webpack/universalModuleDefinition","webpack:///lw.raster-to-gcode.min.js","webpack:///webpack/bootstrap 2ad52f423536c56f847d","webpack:///./raster-to-gcode.js","webpack:///../~/lw.canvas-grid/dist/lw.canvas-grid.js"],"names":["root","factory","exports","module","define","amd","this","modules","__webpack_require__","moduleId","installedModules","id","loaded","call","m","c","p","_interopRequireDefault","obj","__esModule","default","_classCallCheck","instance","Constructor","TypeError","_possibleConstructorReturn","self","ReferenceError","_inherits","subClass","superClass","prototype","Object","create","constructor","value","enumerable","writable","configurable","setPrototypeOf","__proto__","defineProperty","RasterToGcode","undefined","_typeof","Symbol","iterator","_createClass","defineProperties","target","props","i","length","descriptor","key","protoProps","staticProps","_get","get","object","property","receiver","Function","desc","getOwnPropertyDescriptor","parent","getPrototypeOf","getter","_lw","_lw2","_CanvasGrid","settings","assign","ppi","x","y","toolDiameter","rapidRate","feedRate","rateUnit","beamRange","min","max","beamPower","milling","zSafe","zSurface","zDepth","passDepth","offsets","X","Y","trimLine","joinPixel","burnWhite","verboseG","diagonal","overscan","precision","S","nonBlocking","filters","smoothing","brightness","contrast","gamma","grayscale","shadesOfGray","invertColor","onProgress","onProgressContext","onDone","onDoneContext","onAbort","onAbortContext","_this","Error","passes","Math","abs","floor","ppm","parseFloat","toFixed","scaleRatio","running","gcode","gcodes","currentLine","lastCommands","outputSize","width","height","G1","G0","beamOffset","realBeamRange","_registerUserCallbacks","callbacks","on","size","_addHeader","_scanDiagonally","_scanHorizontally","push","options","splice","join","range","name","commands","Array","slice","arguments","command","line","il","_command","apply","defaultValue","pixel","getPixel","gray","error","index","point","G","s","_mapPixelPower","first","lastWhite","last","lastColored","shift","pop","points","power","reversed","pixels","firstPoint","lastPoint","rightPoint","leftPoint","unshift","_processMillingLine","_processLaserLine","_this2","_trimCurrentLine","_reduceCurrentLine","reverse","addCommand","_getPoint","plung","Z","zMax","pass","passNum","_this3","_overscanCurrentLine","_this4","w","h","computeCurrentLine","_getPixelPower","percent","lastPercent","processCurrentLine","_processCurrentLine","round","_onProgress","processNextLine","setTimeout","forEach","_onDone","_onAbort","_this5","totalLines","lineNum","event","callback","context","_this6","method","toUpperCase","_this7","heightMap","CanvasGrid","cellSize","cols","rows","file","image","url","canvas","input","File","loadFromFile","Image","loadFromImage","URL","loadFromURL","trim","Promise","reject","src","resolve","onload","then","catch","onerror","_loadImage","createObjectURL","_processImage","ceil","sx","sy","sw","sh","document","createElement","getContext","fillStyle","fillRect","drawImage","parseInt","isNaN","col","row","pixelData","getImageData","data","color","r","g","b","a","grid","coords","exp","log","algorithm","shades","grayscaleAlgorithms","indexOf","canvasFilters","imageSmoothingEnabled","mozImageSmoothingEnabled","webkitImageSmoothingEnabled","msImageSmoothingEnabled","oImageSmoothingEnabled","imageData","contrastFactor","brightnessOffset","gammaCorrection","shadesOfGrayFactor","putImageData"],"mappings":"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","file":"lw.raster-to-gcode.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"RasterToGcode\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RasterToGcode\"] = factory();\n\telse\n\t\troot[\"RasterToGcode\"] = factory();\n})(this, function() {\nreturn \n\n\n// WEBPACK FOOTER //\n// webpack/universalModuleDefinition","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"RasterToGcode\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"RasterToGcode\"] = factory();\n\telse\n\t\troot[\"RasterToGcode\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.RasterToGcode = undefined;\n\t\n\tvar _typeof = typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; };\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if (\"value\" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };\n\t\n\tvar _lw = __webpack_require__(2);\n\t\n\tvar _lw2 = _interopRequireDefault(_lw);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\tfunction _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return call && (typeof call === \"object\" || typeof call === \"function\") ? call : self; }\n\t\n\tfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }\n\t\n\t// RasterToGcode class\n\tvar RasterToGcode = function (_CanvasGrid) {\n\t    _inherits(RasterToGcode, _CanvasGrid);\n\t\n\t    // Class constructor...\n\t    function RasterToGcode(settings) {\n\t        _classCallCheck(this, RasterToGcode);\n\t\n\t        // Defaults settings\n\t        settings = Object.assign({\n\t            ppi: { x: 254, y: 254 }, // Pixel Per Inch (25.4 ppi == 1 ppm)\n\t\n\t            toolDiameter: 0.1, // Tool diameter in millimeters\n\t            rapidRate: 1500, // Rapid rate in mm/min (G0 F value)\n\t            feedRate: 500, // Feed rate in mm/min (G1 F value)\n\t            rateUnit: 'mm/min', // Rapid/Feed rate unit [mm/min, mm/sec]\n\t\n\t            beamRange: { min: 0, max: 1 }, // Beam power range (Firmware value)\n\t            beamPower: { min: 0, max: 100 }, // Beam power (S value) as percentage of beamRange\n\t\n\t            milling: false, // EXPERIMENTAL\n\t            zSafe: 5, // Safe Z for fast move\n\t            zSurface: 0, // Usinable surface (white pixels)\n\t            zDepth: -10, // Z depth (black pixels)\n\t            passDepth: 1, // Pass depth in millimeters\n\t\n\t            offsets: { X: 0, Y: 0 }, // Global coordinates offsets\n\t            trimLine: true, // Trim trailing white pixels\n\t            joinPixel: true, // Join consecutive pixels with same intensity\n\t            burnWhite: true, // [true = G1 S0 | false = G0] on inner white pixels\n\t            verboseG: false, // Output verbose GCode (print each commands)\n\t            diagonal: false, // Go diagonally (increase the distance between points)\n\t            overscan: 0, // Add some extra white space (in millimeters) before and after each line\n\t\n\t            precision: { X: 2, Y: 2, S: 4 }, // Number of decimals for each commands\n\t\n\t            nonBlocking: true, // Use setTimeout to avoid blocking the UI\n\t\n\t            filters: {\n\t                smoothing: 0, // Smoothing the input image ?\n\t                brightness: 0, // Image brightness [-255 to +255]\n\t                contrast: 0, // Image contrast [-255 to +255]\n\t                gamma: 0, // Image gamma correction [0.01 to 7.99]\n\t                grayscale: 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n\t                shadesOfGray: 256, // Number of shades of gray [2-256]\n\t                invertColor: false // Invert color...\n\t            },\n\t\n\t            onProgress: null, // On progress callbacks\n\t            onProgressContext: null, // On progress callback context\n\t\n\t            onDone: null, // On done callback\n\t            onDoneContext: null, // On done callback context\n\t\n\t            onAbort: null, // On abort callback\n\t            onAbortContext: null // On abort callback context\n\t        }, settings || {});\n\t\n\t        // Init properties\n\t\n\t        // Milling settings\n\t        var _this = _possibleConstructorReturn(this, (RasterToGcode.__proto__ || Object.getPrototypeOf(RasterToGcode)).call(this, settings));\n\t\n\t        if (_this.milling) {\n\t            if (_this.zSafe < _this.zSurface) {\n\t                throw new Error('\"zSafe\" must be greater to \"zSurface\"');\n\t            }\n\t\n\t            _this.passes = Math.abs(Math.floor(_this.zDepth / _this.passDepth));\n\t        }\n\t\n\t        // Negative beam size ?\n\t        if (_this.toolDiameter <= 0) {\n\t            throw new Error('\"toolDiameter\" must be positive');\n\t        }\n\t\n\t        // Uniforme ppi\n\t        if (!_this.ppi.x) {\n\t            _this.ppi = { x: _this.ppi, y: _this.ppi };\n\t        }\n\t\n\t        // Calculate PPM = Pixel Per Millimeters\n\t        _this.ppm = {\n\t            x: parseFloat((2540 / (_this.ppi.x * 100)).toFixed(10)),\n\t            y: parseFloat((2540 / (_this.ppi.y * 100)).toFixed(10))\n\t        };\n\t\n\t        // Calculate scale ratio\n\t        _this.scaleRatio = {\n\t            x: _this.ppm.x / _this.toolDiameter,\n\t            y: _this.ppm.y / _this.toolDiameter\n\t        };\n\t\n\t        // State...\n\t        _this.running = false;\n\t        _this.gcode = null;\n\t        _this.gcodes = null;\n\t        _this.currentLine = null;\n\t        _this.lastCommands = null;\n\t\n\t        // Output size in millimeters\n\t        _this.outputSize = { width: 0, height: 0 };\n\t\n\t        // G0 command\n\t        _this.G1 = ['G', 1];\n\t        _this.G0 = ['G', _this.burnWhite ? 1 : 0];\n\t\n\t        // Calculate beam offset\n\t        _this.beamOffset = _this.toolDiameter * 1000 / 2000;\n\t\n\t        // Calculate real beam range\n\t        _this.realBeamRange = {\n\t            min: _this.beamRange.max / 100 * _this.beamPower.min,\n\t            max: _this.beamRange.max / 100 * _this.beamPower.max\n\t        };\n\t\n\t        // Adjuste feed rate to mm/min\n\t        if (_this.rateUnit === 'mm/sec') {\n\t            _this.feedRate *= 60;\n\t            _this.rapidRate *= 60;\n\t        }\n\t\n\t        // Register user callbacks\n\t        _this._registerUserCallbacks(_this);\n\t        return _this;\n\t    }\n\t\n\t    // Register user callbacks\n\t\n\t\n\t    _createClass(RasterToGcode, [{\n\t        key: '_registerUserCallbacks',\n\t        value: function _registerUserCallbacks(callbacks) {\n\t            // Register user callbacks\n\t            callbacks.onProgress && this.on('progress', callbacks.onProgress, callbacks.onProgressContext);\n\t            callbacks.onAbort && this.on('abort', callbacks.onAbort, callbacks.onAbortContext);\n\t            callbacks.onDone && this.on('done', callbacks.onDone, callbacks.onDoneContext);\n\t        }\n\t\n\t        // Process image\n\t\n\t    }, {\n\t        key: '_processImage',\n\t        value: function _processImage() {\n\t            // Call parent method\n\t            _get(RasterToGcode.prototype.__proto__ || Object.getPrototypeOf(RasterToGcode.prototype), '_processImage', this).call(this);\n\t\n\t            // Calculate output size\n\t            this.outputSize = {\n\t                width: this.size.width * (this.toolDiameter * 1000) / 1000,\n\t                height: this.size.height * (this.toolDiameter * 1000) / 1000\n\t            };\n\t        }\n\t\n\t        // Abort job\n\t\n\t    }, {\n\t        key: 'abort',\n\t        value: function abort() {\n\t            this.running = false;\n\t        }\n\t\n\t        // Process image and return gcode string\n\t\n\t    }, {\n\t        key: 'run',\n\t        value: function run(settings) {\n\t            if (this.running) {\n\t                return;\n\t            }\n\t\n\t            // Reset state\n\t            this.running = true;\n\t            this.gcode = [];\n\t            this.gcodes = [];\n\t            this.lastCommands = {};\n\t            this.currentLine = null;\n\t\n\t            // Defaults settings\n\t            settings = settings || {};\n\t\n\t            // Register user callbacks\n\t            this._registerUserCallbacks(settings);\n\t\n\t            // Non blocking mode ?\n\t            var nonBlocking = this.nonBlocking;\n\t\n\t            if (settings.nonBlocking !== undefined) {\n\t                nonBlocking = settings.nonBlocking;\n\t            }\n\t\n\t            // Add gcode header\n\t            this._addHeader();\n\t\n\t            // Scan type ?\n\t            if (this.diagonal) {\n\t                this._scanDiagonally(nonBlocking);\n\t            } else {\n\t                this._scanHorizontally(nonBlocking);\n\t            }\n\t\n\t            if (!nonBlocking) {\n\t                return this.gcode;\n\t            }\n\t        }\n\t    }, {\n\t        key: '_addHeader',\n\t        value: function _addHeader() {\n\t            // Base headers\n\t            this.gcode.push('; Generated by LaserWeb (lw.raster-to-gcode.js)', '; Size       : ' + this.outputSize.width + ' x ' + this.outputSize.height + ' mm', '; PPI        : x: ' + this.ppi.x + ' - y: ' + this.ppi.y, '; PPM        : x: ' + this.ppm.x + ' - y: ' + this.ppm.y, '; Tool diam. : ' + this.toolDiameter + ' mm', '; Rapid rate : ' + this.rapidRate + ' ' + this.rateUnit, '; Feed rate  : ' + this.feedRate + ' ' + this.rateUnit);\n\t\n\t            if (this.milling) {\n\t                this.gcode.push('; Z safe     : ' + this.zSafe, '; Z surface  : ' + this.zSurface, '; Z depth    : ' + this.zDepth);\n\t            } else {\n\t                this.gcode.push('; Beam range : ' + this.beamRange.min + ' to ' + this.beamRange.max, '; Beam power : ' + this.beamPower.min + ' to ' + this.beamPower.max + ' %');\n\t            }\n\t\n\t            // Print activated options\n\t            var options = ['smoothing', 'trimLine', 'joinPixel', 'burnWhite', 'verboseG', 'diagonal'];\n\t\n\t            for (var i = options.length - 1; i >= 0; i--) {\n\t                if (!this[options[i]]) {\n\t                    options.splice(i, 1);\n\t                }\n\t            }\n\t\n\t            if (options.length) {\n\t                this.gcode.push('; Options    : ' + options.join(', '));\n\t            }\n\t\n\t            // Set feed rates\n\t            this.gcode.push('', 'G0 F' + this.rapidRate, 'G1 F' + this.feedRate, '');\n\t        }\n\t\n\t        // Map S value to pixel power\n\t\n\t    }, {\n\t        key: '_mapPixelPower',\n\t        value: function _mapPixelPower(value) {\n\t            var range = this.milling ? { min: 0, max: this.zDepth } : this.realBeamRange;\n\t            return value * (range.max - range.min) / 255 + range.min;\n\t        }\n\t\n\t        // Compute and return a command, return null if not changed\n\t\n\t    }, {\n\t        key: '_command',\n\t        value: function _command(name, value) {\n\t            // If the value argument is an object\n\t            if ((typeof value === 'undefined' ? 'undefined' : _typeof(value)) === 'object') {\n\t                // Computed commands line\n\t                var commands = Array.prototype.slice.call(arguments);\n\t                var command = void 0,\n\t                    line = [];\n\t\n\t                // for each command\n\t                for (var i = 0, il = commands.length; i < il; i++) {\n\t                    command = this._command.apply(this, commands[i]);\n\t                    command && line.push(command);\n\t                }\n\t\n\t                // Return the line if not empty\n\t                return line.length ? line.join(' ') : null;\n\t            }\n\t\n\t            // Format the value\n\t            value = value.toFixed(this.precision[name] || 0);\n\t\n\t            // If the value was changed or if verbose mode on\n\t            if (this.verboseG || value !== this.lastCommands[name]) {\n\t                this.lastCommands[name] = value;\n\t                return name + value;\n\t            }\n\t\n\t            // No change\n\t            return null;\n\t        }\n\t\n\t        // Get a pixel power value from the canvas data grid\n\t\n\t    }, {\n\t        key: '_getPixelPower',\n\t        value: function _getPixelPower(x, y, defaultValue) {\n\t            try {\n\t                // Reverse Y value since canvas as top/left origin\n\t                y = this.size.height - y - 1;\n\t\n\t                // Get pixel info\n\t                var pixel = this.getPixel(x, y);\n\t\n\t                // Reversed gray value [ 0 = white | 255 = black ]\n\t                return 255 - pixel.gray;\n\t            } catch (error) {\n\t                if (arguments.length === 3) {\n\t                    return defaultValue;\n\t                }\n\t                throw error;\n\t            }\n\t        }\n\t\n\t        // Get a point from the current line with real world coordinates\n\t\n\t    }, {\n\t        key: '_getPoint',\n\t        value: function _getPoint(index) {\n\t            // Get the point object from the current line\n\t            var point = this.currentLine[index];\n\t\n\t            // No point\n\t            if (!point) {\n\t                return null;\n\t            }\n\t\n\t            // Commands\n\t            point.G = point.s ? ['G', 1] : this.G0;\n\t            point.X = point.x * this.toolDiameter + this.offsets.X;\n\t            point.Y = point.y * this.toolDiameter + this.offsets.Y;\n\t            point.S = this._mapPixelPower(point.s);\n\t\n\t            // Offsets\n\t            if (this.diagonal) {\n\t                // Vertical offset\n\t                point.Y += this.toolDiameter;\n\t\n\t                // Horizontal offset\n\t                if (point.first || point.lastWhite) {\n\t                    point.X += this.beamOffset;\n\t                    point.Y -= this.beamOffset;\n\t                } else if (point.last || point.lastColored) {\n\t                    point.X -= this.beamOffset;\n\t                    point.Y += this.beamOffset;\n\t                }\n\t            } else {\n\t                // Vertical offset\n\t                point.Y += this.beamOffset;\n\t\n\t                // Horizontal offset\n\t                if (point.first || point.lastWhite) {\n\t                    point.X += this.beamOffset;\n\t                } else if (point.last || point.lastColored) {\n\t                    point.X -= this.beamOffset;\n\t                }\n\t            }\n\t\n\t            // Return the point\n\t            return point;\n\t        }\n\t\n\t        // Remove all trailing white spaces from the current line\n\t\n\t    }, {\n\t        key: '_trimCurrentLine',\n\t        value: function _trimCurrentLine() {\n\t            // Remove white spaces from the left\n\t            var point = this.currentLine[0];\n\t\n\t            while (point && !point.p) {\n\t                this.currentLine.shift();\n\t                point = this.currentLine[0];\n\t            }\n\t\n\t            // Remove white spaces from the right\n\t            point = this.currentLine[this.currentLine.length - 2];\n\t\n\t            while (point && !point.p) {\n\t                this.currentLine.pop();\n\t                point = this.currentLine[this.currentLine.length - 2];\n\t            }\n\t\n\t            // Return the new line length\n\t            return this.currentLine.length;\n\t        }\n\t\n\t        // Join pixel with same power\n\t\n\t    }, {\n\t        key: '_reduceCurrentLine',\n\t        value: function _reduceCurrentLine() {\n\t            // Line too short to be reduced\n\t            if (this.currentLine.length < 3) {\n\t                return this.currentLine.length;\n\t            }\n\t\n\t            // Extract all points exept the first one\n\t            var points = this.currentLine.splice(1);\n\t\n\t            // Get current power\n\t            var power = this.currentLine[0].p;\n\t\n\t            // For each extracted point\n\t            for (var point, i = 0, il = points.length - 1; i < il; i++) {\n\t                // Current point\n\t                point = points[i];\n\t\n\t                // On power change\n\t                if (power !== point.p) {\n\t                    this.currentLine.push(point);\n\t                }\n\t\n\t                // Update power\n\t                power = point.p;\n\t            }\n\t\n\t            // Add last point\n\t            this.currentLine.push(points[i]);\n\t        }\n\t\n\t        // Add extra white pixels at the ends\n\t\n\t    }, {\n\t        key: '_overscanCurrentLine',\n\t        value: function _overscanCurrentLine(reversed) {\n\t            // Number of pixels to add on each side\n\t            var pixels = this.overscan / this.ppm.x;\n\t\n\t            // Get first/last point\n\t            var firstPoint = this.currentLine[0];\n\t            var lastPoint = this.currentLine[this.currentLine.length - 1];\n\t\n\t            // Is last white/colored point ?\n\t            firstPoint.s && (firstPoint.lastWhite = true);\n\t            lastPoint.s && (lastPoint.lastColored = true);\n\t\n\t            // Reversed line ?\n\t            reversed ? lastPoint.s = 0 : firstPoint.s = 0;\n\t\n\t            // Create left/right points\n\t            var rightPoint = { x: lastPoint.x + pixels, y: lastPoint.y, s: 0, p: 0 };\n\t            var leftPoint = { x: firstPoint.x - pixels, y: firstPoint.y, s: 0, p: 0 };\n\t\n\t            if (this.diagonal) {\n\t                leftPoint.y += pixels;\n\t                rightPoint.y -= pixels;\n\t            }\n\t\n\t            // Add left/right points to current line\n\t            this.currentLine.unshift(leftPoint);\n\t            this.currentLine.push(rightPoint);\n\t        }\n\t\n\t        // Process current line and return an array of GCode text lines\n\t\n\t    }, {\n\t        key: '_processCurrentLine',\n\t        value: function _processCurrentLine(reversed) {\n\t            if (this.milling) {\n\t                return this._processMillingLine(reversed);\n\t            }\n\t\n\t            return this._processLaserLine(reversed);\n\t        }\n\t\n\t        // Process current line and return an array of GCode text lines\n\t\n\t    }, {\n\t        key: '_processMillingLine',\n\t        value: function _processMillingLine(reversed) {\n\t            var _this2 = this;\n\t\n\t            // Skip empty line\n\t            if (!this._trimCurrentLine()) {\n\t                return null;\n\t            }\n\t\n\t            // Join pixel with same power\n\t            if (this.joinPixel) {\n\t                this._reduceCurrentLine();\n\t            }\n\t\n\t            // Mark first and last point on the current line\n\t            this.currentLine[0].first = true;\n\t            this.currentLine[this.currentLine.length - 1].last = true;\n\t\n\t            // Reversed line ?\n\t            if (reversed) {\n\t                this.currentLine = this.currentLine.reverse();\n\t            }\n\t\n\t            // Point index\n\t            var point = void 0,\n\t                index = 0;\n\t\n\t            // Init loop vars...\n\t            var command = void 0,\n\t                gcode = [];\n\t\n\t            var addCommand = function addCommand() {\n\t                command = _this2._command.apply(_this2, arguments);\n\t                command && gcode.push(command);\n\t            };\n\t\n\t            // Get first point\n\t            point = this._getPoint(index);\n\t\n\t            var plung = false;\n\t            var Z = void 0,\n\t                zMax = void 0;\n\t\n\t            var pass = function pass(passNum) {\n\t                // Move to start of the line\n\t                addCommand(['G', 0], ['Z', _this2.zSafe]);\n\t                addCommand(['G', 0], ['X', point.X], ['Y', point.Y]);\n\t                addCommand(['G', 0], ['Z', _this2.zSurface]);\n\t\n\t                // For each point on the line\n\t                while (point) {\n\t                    if (point.S) {\n\t                        if (plung) {\n\t                            addCommand(['G', 0], ['Z', _this2.zSurface]);\n\t                            plung = false;\n\t                        }\n\t\n\t                        Z = point.S;\n\t                        zMax = _this2.passDepth * passNum;\n\t\n\t                        // Last pass\n\t                        if (passNum < _this2.passes) {\n\t                            Z = Math.max(Z, -zMax);\n\t                        }\n\t\n\t                        addCommand(['G', 1], ['Z', _this2.zSurface + Z]);\n\t                        addCommand(['G', 1], ['X', point.X], ['Y', point.Y]);\n\t                    } else {\n\t                        if (plung) {\n\t                            addCommand(['G', 1], ['Z', _this2.zSurface]);\n\t                            plung = false;\n\t                        }\n\t\n\t                        addCommand(['G', 0], ['Z', _this2.zSafe]);\n\t                        addCommand(['G', 0], ['X', point.X], ['Y', point.Y]);\n\t                    }\n\t\n\t                    if (point.lastWhite || point.lastColored) {\n\t                        plung = true;\n\t                    }\n\t\n\t                    // Get next point\n\t                    point = _this2._getPoint(++index);\n\t                }\n\t\n\t                // Move to Z safe\n\t                addCommand(['G', 1], ['Z', _this2.zSurface]);\n\t                addCommand(['G', 0], ['Z', _this2.zSafe]);\n\t            };\n\t\n\t            for (var i = 1; i <= this.passes; i++) {\n\t                pass(i);\n\t\n\t                if (!gcode.length) {\n\t                    break;\n\t                }\n\t\n\t                if (this.gcodes.length < i) {\n\t                    this.gcodes.push([]);\n\t                } else {\n\t                    this.gcodes[i - 1].push.apply(this.gcodes[i - 1], gcode);\n\t                }\n\t\n\t                index = 0;\n\t                gcode = [];\n\t                point = this._getPoint(index);\n\t\n\t                this.lastCommands = {};\n\t            }\n\t\n\t            // Not sure what to return...\n\t            return null;\n\t        }\n\t\n\t        // Process current line and return an array of GCode text lines\n\t\n\t    }, {\n\t        key: '_processLaserLine',\n\t        value: function _processLaserLine(reversed) {\n\t            var _this3 = this;\n\t\n\t            // Trim trailing white spaces ?\n\t            if (this.trimLine && !this._trimCurrentLine()) {\n\t                // Skip empty line\n\t                return null;\n\t            }\n\t\n\t            // Join pixel with same power\n\t            if (this.joinPixel) {\n\t                this._reduceCurrentLine();\n\t            }\n\t\n\t            // Overscan ?\n\t            if (this.overscan) {\n\t                this._overscanCurrentLine(reversed);\n\t            }\n\t\n\t            // Mark first and last point on the current line\n\t            this.currentLine[0].first = true;\n\t            this.currentLine[this.currentLine.length - 1].last = true;\n\t\n\t            // Reversed line ?\n\t            if (reversed) {\n\t                this.currentLine = this.currentLine.reverse();\n\t            }\n\t\n\t            // Point index\n\t            var point = void 0,\n\t                index = 0;\n\t\n\t            // Init loop vars...\n\t            var command = void 0,\n\t                gcode = [];\n\t\n\t            var addCommand = function addCommand() {\n\t                command = _this3._command.apply(_this3, arguments);\n\t                command && gcode.push(command);\n\t            };\n\t\n\t            // Get first point\n\t            point = this._getPoint(index);\n\t\n\t            // Move to start of the line\n\t            addCommand(this.G0, ['X', point.X], ['Y', point.Y], ['S', 0]);\n\t\n\t            // For each point on the line\n\t            while (point) {\n\t                // Burn to next point\n\t                addCommand(point.G, ['X', point.X], ['Y', point.Y], ['S', point.S]);\n\t\n\t                // Get next point\n\t                point = this._getPoint(++index);\n\t            }\n\t\n\t            // Return gcode commands array\n\t            if (gcode.length) {\n\t                return gcode;\n\t            }\n\t\n\t            // Empty line\n\t            return null;\n\t        }\n\t\n\t        // Parse horizontally\n\t\n\t    }, {\n\t        key: '_scanHorizontally',\n\t        value: function _scanHorizontally(nonBlocking) {\n\t            var _this4 = this;\n\t\n\t            // Init loop vars\n\t            var x = 0,\n\t                y = 0;\n\t            var s = void 0,\n\t                p = void 0,\n\t                point = void 0,\n\t                gcode = void 0;\n\t            var w = this.size.width;\n\t            var h = this.size.height;\n\t\n\t            var reversed = false;\n\t            var lastWhite = false;\n\t            var lastColored = false;\n\t\n\t            var computeCurrentLine = function computeCurrentLine() {\n\t                // Reset current line\n\t                _this4.currentLine = [];\n\t\n\t                // Reset point object\n\t                point = null;\n\t\n\t                // For each pixel on the line\n\t                for (x = 0; x <= w; x++) {\n\t                    // Get pixel power\n\t                    s = p = _this4._getPixelPower(x, y, p);\n\t\n\t                    // Is last white/colored pixel\n\t                    lastWhite = point && !point.p && p;\n\t                    lastColored = point && point.p && !p;\n\t\n\t                    // Pixel color from last one on normal line\n\t                    if (!reversed && point) {\n\t                        s = point.p;\n\t                    }\n\t\n\t                    // Create point object\n\t                    point = { x: x, y: y, s: s, p: p };\n\t\n\t                    // Set last white/colored pixel\n\t                    lastWhite && (point.lastWhite = true);\n\t                    lastColored && (point.lastColored = true);\n\t\n\t                    // Add point to current line\n\t                    _this4.currentLine.push(point);\n\t                }\n\t            };\n\t\n\t            var percent = 0;\n\t            var lastPercent = 0;\n\t\n\t            var processCurrentLine = function processCurrentLine() {\n\t                // Process pixels line\n\t                gcode = _this4._processCurrentLine(reversed);\n\t\n\t                // Call progress callback\n\t                percent = Math.round(y / h * 100);\n\t\n\t                if (percent > lastPercent) {\n\t                    _this4._onProgress({ gcode: gcode, percent: percent });\n\t                }\n\t\n\t                lastPercent = percent;\n\t\n\t                // Skip empty gcode line\n\t                if (!gcode) {\n\t                    return;\n\t                }\n\t\n\t                // Toggle line state\n\t                reversed = !reversed;\n\t\n\t                // Concat line\n\t                _this4.gcode.push.apply(_this4.gcode, gcode);\n\t            };\n\t\n\t            var processNextLine = function processNextLine() {\n\t                // Aborted ?\n\t                if (!_this4.running) {\n\t                    return _this4._onAbort();\n\t                }\n\t\n\t                // Process line...\n\t                computeCurrentLine();\n\t                processCurrentLine();\n\t\n\t                y++;\n\t\n\t                if (y < h) {\n\t                    if (nonBlocking) {\n\t                        setTimeout(processNextLine, 0);\n\t                    } else {\n\t                        processNextLine();\n\t                    }\n\t                } else {\n\t                    if (_this4.milling) {\n\t                        _this4.gcodes.forEach(function (gcode) {\n\t                            _this4.gcode.push.apply(_this4.gcode, gcode);\n\t                        });\n\t                    }\n\t\n\t                    _this4._onDone({ gcode: _this4.gcode });\n\t                    _this4.running = false;\n\t                }\n\t            };\n\t\n\t            processNextLine();\n\t        }\n\t\n\t        // Parse diagonally\n\t\n\t    }, {\n\t        key: '_scanDiagonally',\n\t        value: function _scanDiagonally(nonBlocking) {\n\t            var _this5 = this;\n\t\n\t            // Init loop vars\n\t            var x = 0,\n\t                y = 0;\n\t            var s = void 0,\n\t                p = void 0,\n\t                point = void 0,\n\t                gcode = void 0;\n\t            var w = this.size.width;\n\t            var h = this.size.height;\n\t\n\t            var totalLines = w + h - 1;\n\t            var lineNum = 0;\n\t            var reversed = false;\n\t            var lastWhite = false;\n\t            var lastColored = false;\n\t\n\t            var computeCurrentLine = function computeCurrentLine(x, y) {\n\t                // Reset current line\n\t                _this5.currentLine = [];\n\t\n\t                // Reset point object\n\t                point = null;\n\t\n\t                // Increment line num\n\t                lineNum++;\n\t\n\t                while (true) {\n\t                    // Y limit reached !\n\t                    if (y < -1 || y == h) {\n\t                        break;\n\t                    }\n\t\n\t                    // X limit reached !\n\t                    if (x < 0 || x > w) {\n\t                        break;\n\t                    }\n\t\n\t                    // Get pixel power\n\t                    s = p = _this5._getPixelPower(x, y, p);\n\t\n\t                    // Is last white/colored pixel\n\t                    lastWhite = point && !point.p && p;\n\t                    lastColored = point && point.p && !p;\n\t\n\t                    // Pixel color from last one on normal line\n\t                    if (!reversed && point) {\n\t                        s = point.p;\n\t                    }\n\t\n\t                    // Create point object\n\t                    point = { x: x, y: y, s: s, p: p };\n\t\n\t                    // Set last white/colored pixel\n\t                    lastWhite && (point.lastWhite = true);\n\t                    lastColored && (point.lastColored = true);\n\t\n\t                    // Add the new point\n\t                    _this5.currentLine.push(point);\n\t\n\t                    // Next coords\n\t                    x++;\n\t                    y--;\n\t                }\n\t            };\n\t\n\t            var percent = 0;\n\t            var lastPercent = 0;\n\t\n\t            var processCurrentLine = function processCurrentLine() {\n\t                // Process pixels line\n\t                gcode = _this5._processCurrentLine(reversed);\n\t\n\t                // Call progress callback\n\t                percent = Math.round(lineNum / totalLines * 100);\n\t\n\t                if (percent > lastPercent) {\n\t                    _this5._onProgress({ gcode: gcode, percent: percent });\n\t                }\n\t\n\t                lastPercent = percent;\n\t\n\t                // Skip empty gcode line\n\t                if (!gcode) {\n\t                    return;\n\t                }\n\t\n\t                // Toggle line state\n\t                reversed = !reversed;\n\t\n\t                // Concat line\n\t                _this5.gcode.push.apply(_this5.gcode, gcode);\n\t            };\n\t\n\t            var processNextLine = function processNextLine() {\n\t                // Aborted ?\n\t                if (!_this5.running) {\n\t                    return _this5._onAbort();\n\t                }\n\t\n\t                // Process line...\n\t                computeCurrentLine(x, y);\n\t                processCurrentLine();\n\t\n\t                if (!x) y++;else x++;\n\t\n\t                if (y === h) {\n\t                    x++;\n\t                    y--;\n\t                }\n\t\n\t                if (y < h && x < w) {\n\t                    if (nonBlocking) {\n\t                        setTimeout(processNextLine, 0);\n\t                    } else {\n\t                        processNextLine();\n\t                    }\n\t                } else {\n\t                    _this5._onDone({ gcode: _this5.gcode });\n\t                    _this5.running = false;\n\t                }\n\t            };\n\t\n\t            processNextLine();\n\t        }\n\t    }, {\n\t        key: '_onProgress',\n\t        value: function _onProgress(event) {\n\t            //console.log('progress:', event.percent)\n\t        }\n\t    }, {\n\t        key: '_onDone',\n\t        value: function _onDone(event) {\n\t            //console.log('done:', event.gcode.length)\n\t        }\n\t    }, {\n\t        key: '_onAbort',\n\t        value: function _onAbort() {\n\t            //console.log('abort')\n\t        }\n\t    }, {\n\t        key: 'on',\n\t        value: function on(event, callback, context) {\n\t            var _this6 = this;\n\t\n\t            var method = '_on' + event[0].toUpperCase() + event.slice(1);\n\t\n\t            if (!this[method] || typeof this[method] !== 'function') {\n\t                throw new Error('Undefined event: ' + event);\n\t            }\n\t\n\t            this[method] = function (event) {\n\t                return callback.call(context || _this6, event);\n\t            };\n\t\n\t            return this;\n\t        }\n\t\n\t        // Return the bitmap height-map\n\t\n\t    }, {\n\t        key: 'getHeightMap',\n\t        value: function getHeightMap(settings) {\n\t            var _this7 = this;\n\t\n\t            if (this.running) {\n\t                return;\n\t            }\n\t\n\t            // Init loop vars\n\t            this.running = true;\n\t            var heightMap = [];\n\t\n\t            var x = 0;\n\t            var y = 0;\n\t            var w = this.size.width;\n\t            var h = this.size.height;\n\t\n\t            var percent = 0;\n\t            var lastPercent = 0;\n\t\n\t            // Defaults settings\n\t            settings = settings || {};\n\t\n\t            // Register user callbacks\n\t            this._registerUserCallbacks(settings);\n\t\n\t            // Non blocking mode ?\n\t            var nonBlocking = this.nonBlocking;\n\t\n\t            if (settings.nonBlocking !== undefined) {\n\t                nonBlocking = settings.nonBlocking;\n\t            }\n\t\n\t            var computeCurrentLine = function computeCurrentLine() {\n\t                // Reset current line\n\t                var pixels = [];\n\t\n\t                // For each pixel on the line\n\t                for (x = 0; x < w; x++) {\n\t                    pixels.push(_this7._mapPixelPower(_this7._getPixelPower(x, y)));\n\t                }\n\t\n\t                // Call progress callback\n\t                percent = Math.round(y / h * 100);\n\t\n\t                if (percent > lastPercent) {\n\t                    //onProgress.call(settings.progressContext || this, { pixels, percent })\n\t                    _this7._onProgress({ pixels: pixels, percent: percent });\n\t                }\n\t\n\t                lastPercent = percent;\n\t\n\t                // Add pixels line\n\t                heightMap.push(pixels);\n\t            };\n\t\n\t            var processNextLine = function processNextLine() {\n\t                // Aborted ?\n\t                if (!_this7.running) {\n\t                    return _this7._onAbort();\n\t                }\n\t\n\t                // Process line...\n\t                computeCurrentLine();\n\t\n\t                y++;\n\t\n\t                if (y < h) {\n\t                    if (nonBlocking) {\n\t                        setTimeout(processNextLine, 0);\n\t                    } else {\n\t                        processNextLine();\n\t                    }\n\t                } else {\n\t                    //onDone.call(settings.doneContext || this, { heightMap })\n\t                    _this7._onDone({ heightMap: heightMap });\n\t                    _this7.running = false;\n\t                }\n\t            };\n\t\n\t            processNextLine();\n\t\n\t            if (!nonBlocking) {\n\t                return heightMap;\n\t            }\n\t        }\n\t    }]);\n\t\n\t    return RasterToGcode;\n\t}(_lw2.default);\n\t\n\t// Exports\n\t\n\t\n\texports.RasterToGcode = RasterToGcode;\n\texports.default = RasterToGcode;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine(\"CanvasGrid\", [], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"CanvasGrid\"] = factory();\n\t\telse\n\t\t\troot[\"CanvasGrid\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\tmodule.exports = __webpack_require__(1);\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t'use strict';\n\t\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t    value: true\n\t\t});\n\t\texports.CanvasGrid = undefined;\n\t\t\n\t\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\t\n\t\tvar _lw = __webpack_require__(2);\n\t\t\n\t\tvar _lw2 = _interopRequireDefault(_lw);\n\t\t\n\t\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\t\n\t\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\t\n\t\t// CanvasGrid class\n\t\tvar CanvasGrid = function () {\n\t\t    // Class constructor...\n\t\t    function CanvasGrid(settings) {\n\t\t        _classCallCheck(this, CanvasGrid);\n\t\t\n\t\t        // Init properties\n\t\t        this.cellSize = 1024;\n\t\t        this.scaleRatio = { x: 1, y: 1 };\n\t\t        this.filters = {};\n\t\t\n\t\t        Object.assign(this, settings || {});\n\t\t\n\t\t        if (!this.scaleRatio.x) {\n\t\t            this.scaleRatio = { x: this.scaleRatio, y: this.scaleRatio };\n\t\t        }\n\t\t\n\t\t        this.size = { width: 0, height: 0, cols: 0, rows: 0 };\n\t\t        this.file = null;\n\t\t        this.image = null;\n\t\t        this.url = null;\n\t\t        this.canvas = [];\n\t\t        this.pixels = [];\n\t\t    }\n\t\t\n\t\t    // <input> can be Image, File, URL object or URL string (http://* or data:image/*)\n\t\t\n\t\t\n\t\t    _createClass(CanvasGrid, [{\n\t\t        key: 'load',\n\t\t        value: function load(input) {\n\t\t            // Load File object\n\t\t            if (input instanceof File) {\n\t\t                return this.loadFromFile(input);\n\t\t            }\n\t\t\n\t\t            // Load Image object\n\t\t            if (input instanceof Image) {\n\t\t                return this.loadFromImage(input);\n\t\t            }\n\t\t\n\t\t            // Load URL object\n\t\t            if (typeof input === 'string' || input instanceof URL) {\n\t\t                return this.loadFromURL(input.trim());\n\t\t            }\n\t\t\n\t\t            // Return rejected promise with an Error object\n\t\t            return Promise.reject(new Error('Unsupported input format.'));\n\t\t        }\n\t\t\n\t\t        // Load image\n\t\t\n\t\t    }, {\n\t\t        key: '_loadImage',\n\t\t        value: function _loadImage(src, reject, resolve) {\n\t\t            var _this = this;\n\t\t\n\t\t            // Create Image object\n\t\t            var image = new Image();\n\t\t\n\t\t            // Register for load and error events\n\t\t            image.onload = function (event) {\n\t\t                _this.loadFromImage(image).then(resolve).catch(reject);\n\t\t            };\n\t\t\n\t\t            image.onerror = function (event) {\n\t\t                reject(new Error('An error occurred while loading the image : ' + src));\n\t\t            };\n\t\t\n\t\t            // Load the image from File url\n\t\t            image.src = src;\n\t\t        }\n\t\t\n\t\t        // Load from File object\n\t\t\n\t\t    }, {\n\t\t        key: 'loadFromFile',\n\t\t        value: function loadFromFile(input) {\n\t\t            var _this2 = this;\n\t\t\n\t\t            return new Promise(function (resolve, reject) {\n\t\t                // Bad input type\n\t\t                if (!(input instanceof File)) {\n\t\t                    reject(new Error('Input param must be a File object.'));\n\t\t                }\n\t\t\n\t\t                // Set input file\n\t\t                _this2.file = input;\n\t\t\n\t\t                // Load image\n\t\t                _this2._loadImage(URL.createObjectURL(input), reject, resolve);\n\t\t            });\n\t\t        }\n\t\t\n\t\t        // Load from URL object or string\n\t\t\n\t\t    }, {\n\t\t        key: 'loadFromURL',\n\t\t        value: function loadFromURL(input) {\n\t\t            var _this3 = this;\n\t\t\n\t\t            return new Promise(function (resolve, reject) {\n\t\t                // Bad input type\n\t\t                if (!(input instanceof URL) && typeof input !== 'string') {\n\t\t                    reject(new Error('Input param must be a URL string or object.'));\n\t\t                }\n\t\t\n\t\t                // Create url object\n\t\t                var url = input instanceof URL ? input : new URL(input);\n\t\t\n\t\t                // Set url\n\t\t                _this3.url = url;\n\t\t\n\t\t                // Load image\n\t\t                _this3._loadImage(url, reject, resolve);\n\t\t            });\n\t\t        }\n\t\t\n\t\t        // Load from Image object\n\t\t\n\t\t    }, {\n\t\t        key: 'loadFromImage',\n\t\t        value: function loadFromImage(input) {\n\t\t            var _this4 = this;\n\t\t\n\t\t            return new Promise(function (resolve, reject) {\n\t\t                // Bad input type\n\t\t                if (!(input instanceof Image)) {\n\t\t                    reject(new Error('Input param must be a Image object.'));\n\t\t                }\n\t\t\n\t\t                // Set input image\n\t\t                _this4.image = input;\n\t\t\n\t\t                // Process image\n\t\t                _this4._processImage();\n\t\t\n\t\t                // Resolve the promise\n\t\t                resolve(_this4);\n\t\t            });\n\t\t        }\n\t\t    }, {\n\t\t        key: '_processImage',\n\t\t        value: function _processImage() {\n\t\t            // Reset canvas grid\n\t\t            this.canvas = [];\n\t\t            this.pixels = [];\n\t\t\n\t\t            // Calculate grid size\n\t\t            var width = Math.round(this.image.width * this.scaleRatio.x);\n\t\t            var height = Math.round(this.image.height * this.scaleRatio.y);\n\t\t            var cols = Math.ceil(width / this.cellSize);\n\t\t            var rows = Math.ceil(height / this.cellSize);\n\t\t\n\t\t            this.size = { width: width, height: height, cols: cols, rows: rows };\n\t\t\n\t\t            // Create canvas grid\n\t\t            var line = null;\n\t\t            var canvas = null;\n\t\t            var context = null;\n\t\t\n\t\t            var x = null; // cols\n\t\t            var y = null; // rows\n\t\t            var sx = null; // scaled cols\n\t\t            var sy = null; // scaled rows\n\t\t            var sw = null; // scaled width\n\t\t            var sh = null; // scaled height\n\t\t\n\t\t            // For each line\n\t\t            for (y = 0; y < this.size.rows; y++) {\n\t\t                // Reset current line\n\t\t                line = [];\n\t\t\n\t\t                // For each column\n\t\t                for (x = 0; x < this.size.cols; x++) {\n\t\t                    // Create canvas element\n\t\t                    canvas = document.createElement('canvas');\n\t\t\n\t\t                    // Set canvas size\n\t\t                    if (x === 0 || x < this.size.cols - 1) {\n\t\t                        canvas.width = this.size.width < this.cellSize ? this.size.width : this.cellSize;\n\t\t                    } else {\n\t\t                        // Get the rest for the last item (except the first one)\n\t\t                        canvas.width = this.size.width % this.cellSize;\n\t\t                    }\n\t\t\n\t\t                    if (y === 0 || y < this.size.rows - 1) {\n\t\t                        canvas.height = this.size.height < this.cellSize ? this.size.height : this.cellSize;\n\t\t                    } else {\n\t\t                        // Get the rest for the last item (except the first one)\n\t\t                        canvas.height = this.size.height % this.cellSize;\n\t\t                    }\n\t\t\n\t\t                    // Get canvas 2d context\n\t\t                    context = canvas.getContext('2d');\n\t\t\n\t\t                    // Fill withe background (avoid alpha chanel calculation)\n\t\t                    context.fillStyle = 'white';\n\t\t                    context.fillRect(0, 0, canvas.width, canvas.height);\n\t\t\n\t\t                    // Draw the part of image in the canvas (scale)\n\t\t                    sw = canvas.width / this.scaleRatio.x;\n\t\t                    sh = canvas.height / this.scaleRatio.y;\n\t\t                    sx = x * this.cellSize / this.scaleRatio.x;\n\t\t                    sy = y * this.cellSize / this.scaleRatio.y;\n\t\t\n\t\t                    context.drawImage(this.image, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);\n\t\t\n\t\t                    // Apply image filters\n\t\t                    (0, _lw2.default)(canvas, this.filters);\n\t\t\n\t\t                    // Add the canvas to current line\n\t\t                    line.push(canvas);\n\t\t                }\n\t\t\n\t\t                // Add the line to canvas grid\n\t\t                this.canvas.push(line);\n\t\t            }\n\t\t        }\n\t\t    }, {\n\t\t        key: 'getPixel',\n\t\t        value: function getPixel(x, y) {\n\t\t            // Test coords validity\n\t\t            x = parseInt(x);\n\t\t            y = parseInt(y);\n\t\t\n\t\t            if (isNaN(x) || isNaN(y)) {\n\t\t                throw new Error('[x, y] params must be Integer.');\n\t\t            }\n\t\t\n\t\t            // Test coords range\n\t\t            if (x < 0 || x >= this.size.width) {\n\t\t                throw new Error('Out of range: x = ' + x + ', max: ' + this.size.width);\n\t\t            }\n\t\t\n\t\t            if (y < 0 || y >= this.size.height) {\n\t\t                throw new Error('Out of range: y = ' + y + ', max: ' + this.size.height);\n\t\t            }\n\t\t\n\t\t            // Calculate target canvas coords\n\t\t            var col = parseInt(x / this.cellSize);\n\t\t            var row = parseInt(y / this.cellSize);\n\t\t\n\t\t            // Adjuste x/y values relative to canvas origin\n\t\t            col && (x -= this.cellSize * col);\n\t\t            row && (y -= this.cellSize * row);\n\t\t\n\t\t            // Get pixel data\n\t\t            var canvas = this.canvas[row][col];\n\t\t            var context = canvas.getContext('2d');\n\t\t            var pixelData = context.getImageData(x, y, 1, 1).data;\n\t\t\n\t\t            return {\n\t\t                color: { r: pixelData[0], g: pixelData[1], b: pixelData[2], a: pixelData[3] },\n\t\t                gray: (pixelData[0] + pixelData[1] + pixelData[2]) / 3,\n\t\t                grid: { col: col, row: row },\n\t\t                coords: { x: x, y: y }\n\t\t            };\n\t\t        }\n\t\t    }]);\n\t\t\n\t\t    return CanvasGrid;\n\t\t}();\n\t\t\n\t\t// Exports\n\t\t\n\t\t\n\t\texports.CanvasGrid = CanvasGrid;\n\t\texports.default = CanvasGrid;\n\t\n\t/***/ },\n\t/* 2 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\t\tif(true)\n\t\t\t\tmodule.exports = factory();\n\t\t\telse if(typeof define === 'function' && define.amd)\n\t\t\t\tdefine(\"CanvasFilter\", [], factory);\n\t\t\telse if(typeof exports === 'object')\n\t\t\t\texports[\"CanvasFilter\"] = factory();\n\t\t\telse\n\t\t\t\troot[\"CanvasFilter\"] = factory();\n\t\t})(this, function() {\n\t\treturn /******/ (function(modules) { // webpackBootstrap\n\t\t/******/ \t// The module cache\n\t\t/******/ \tvar installedModules = {};\n\t\t/******/\n\t\t/******/ \t// The require function\n\t\t/******/ \tfunction __webpack_require__(moduleId) {\n\t\t/******/\n\t\t/******/ \t\t// Check if module is in cache\n\t\t/******/ \t\tif(installedModules[moduleId])\n\t\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t\t/******/\n\t\t/******/ \t\t// Create a new module (and put it into the cache)\n\t\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t\t/******/ \t\t\texports: {},\n\t\t/******/ \t\t\tid: moduleId,\n\t\t/******/ \t\t\tloaded: false\n\t\t/******/ \t\t};\n\t\t/******/\n\t\t/******/ \t\t// Execute the module function\n\t\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t\t/******/\n\t\t/******/ \t\t// Flag the module as loaded\n\t\t/******/ \t\tmodule.loaded = true;\n\t\t/******/\n\t\t/******/ \t\t// Return the exports of the module\n\t\t/******/ \t\treturn module.exports;\n\t\t/******/ \t}\n\t\t/******/\n\t\t/******/\n\t\t/******/ \t// expose the modules object (__webpack_modules__)\n\t\t/******/ \t__webpack_require__.m = modules;\n\t\t/******/\n\t\t/******/ \t// expose the module cache\n\t\t/******/ \t__webpack_require__.c = installedModules;\n\t\t/******/\n\t\t/******/ \t// __webpack_public_path__\n\t\t/******/ \t__webpack_require__.p = \"\";\n\t\t/******/\n\t\t/******/ \t// Load entry module and return exports\n\t\t/******/ \treturn __webpack_require__(0);\n\t\t/******/ })\n\t\t/************************************************************************/\n\t\t/******/ ([\n\t\t/* 0 */\n\t\t/***/ function(module, exports, __webpack_require__) {\n\t\t\n\t\t\tmodule.exports = __webpack_require__(1);\n\t\t\n\t\t\n\t\t/***/ },\n\t\t/* 1 */\n\t\t/***/ function(module, exports) {\n\t\t\n\t\t\t'use strict';\n\t\t\t\n\t\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t\t    value: true\n\t\t\t});\n\t\t\t// Grayscale algorithms\n\t\t\tvar grayscaleAlgorithms = ['none', 'average', 'desaturation', 'decomposition-min', 'decomposition-max', 'luma', 'luma-601', 'luma-709', 'luma-240', 'red-chanel', 'green-chanel', 'blue-chanel'];\n\t\t\t\n\t\t\t// Trucate color value in the 0-255 range\n\t\t\tfunction color(color) {\n\t\t\t    return color < 0 ? 0 : color > 255 ? 255 : color;\n\t\t\t}\n\t\t\t\n\t\t\t// Filters ...\n\t\t\tfunction invertColor(data, i, value) {\n\t\t\t    if (value) {\n\t\t\t        data[i] = color(255 - data[i]);\n\t\t\t        data[i + 1] = color(255 - data[i + 1]);\n\t\t\t        data[i + 2] = color(255 - data[i + 2]);\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tfunction brightness(data, i, value) {\n\t\t\t    if (value !== undefined) {\n\t\t\t        data[i] = color(data[i] + value);\n\t\t\t        data[i + 1] = color(data[i + 1] + value);\n\t\t\t        data[i + 2] = color(data[i + 2] + value);\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tfunction contrast(data, i, value) {\n\t\t\t    if (value !== undefined) {\n\t\t\t        data[i] = color(value * (data[i] - 128) + 128);\n\t\t\t        data[i + 1] = color(value * (data[i + 1] - 128) + 128);\n\t\t\t        data[i + 2] = color(value * (data[i + 2] - 128) + 128);\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tfunction gamma(data, i, value) {\n\t\t\t    if (value !== undefined) {\n\t\t\t        data[i] = color(Math.exp(Math.log(255 * (data[i] / 255)) * value));\n\t\t\t        data[i + 1] = color(Math.exp(Math.log(255 * (data[i + 1] / 255)) * value));\n\t\t\t        data[i + 2] = color(Math.exp(Math.log(255 * (data[i + 2] / 255)) * value));\n\t\t\t    }\n\t\t\t}\n\t\t\t\n\t\t\tfunction grayscale(data, i, algorithm, shades) {\n\t\t\t    // Graysale\n\t\t\t    // http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/\n\t\t\t\n\t\t\t    // Unsupported algorithm\n\t\t\t    if (grayscaleAlgorithms.indexOf(algorithm) === -1) {\n\t\t\t        throw new Error('Unsupported grayscale algorithm: ' + algorithm);\n\t\t\t    }\n\t\t\t\n\t\t\t    // None\n\t\t\t    if (algorithm === 'none') {\n\t\t\t        return null;\n\t\t\t    }\n\t\t\t\n\t\t\t    // Get Red/Green/Blue values\n\t\t\t    var gray = void 0;\n\t\t\t    var r = data[i];\n\t\t\t    var g = data[i + 1];\n\t\t\t    var b = data[i + 2];\n\t\t\t\n\t\t\t    switch (algorithm) {\n\t\t\t        case 'average':\n\t\t\t            gray = (r + g + b) / 3;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'luma':\n\t\t\t            // Default\n\t\t\t            gray = r * 0.3 + g * 0.59 + b * 0.11;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'luma-601':\n\t\t\t            // CCIR-601\n\t\t\t            gray = r * 0.299 + g * 0.587 + b * 0.114;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'luma-709':\n\t\t\t            // ITU-R-709\n\t\t\t            gray = r * 0.2126 + g * 0.7152 + b * 0.0722;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'luma-240':\n\t\t\t            // SMPTE-240M\n\t\t\t            gray = r * 0.212 + g * 0.701 + b * 0.087;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'desaturation':\n\t\t\t            gray = (Math.max(r, g, b) + Math.min(r, g, b)) / 2;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'decomposition-min':\n\t\t\t            gray = Math.min(r, g, b);\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'decomposition-max':\n\t\t\t            gray = Math.max(r, g, b);\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'red-chanel':\n\t\t\t            gray = r;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'green-chanel':\n\t\t\t            gray = g;\n\t\t\t            break;\n\t\t\t\n\t\t\t        case 'blue-chanel':\n\t\t\t            gray = b;\n\t\t\t            break;\n\t\t\t    }\n\t\t\t\n\t\t\t    // Shades of gray\n\t\t\t    if (shades !== undefined) {\n\t\t\t        gray = parseInt(gray / shades) * shades;\n\t\t\t    }\n\t\t\t\n\t\t\t    // Force integer\n\t\t\t    gray = parseInt(gray);\n\t\t\t\n\t\t\t    // Set new r/g/b values\n\t\t\t    data[i] = color(gray);\n\t\t\t    data[i + 1] = color(gray);\n\t\t\t    data[i + 2] = color(gray);\n\t\t\t}\n\t\t\t\n\t\t\t// Apply filters on provided canvas\n\t\t\tfunction canvasFilters(canvas, settings) {\n\t\t\t    settings = Object.assign({}, {\n\t\t\t        smoothing: false, // Smoothing [true|fale]\n\t\t\t        brightness: 0, // Image brightness [-255 to +255]\n\t\t\t        contrast: 0, // Image contrast [-255 to +255]\n\t\t\t        gamma: 0, // Image gamma correction [0.01 to 7.99]\n\t\t\t        grayscale: 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n\t\t\t        shadesOfGray: 256, // Number of shades of gray [2-256]\n\t\t\t        invertColor: false // Invert color...\n\t\t\t    }, settings || {});\n\t\t\t\n\t\t\t    // Get canvas 2d context\n\t\t\t    var context = canvas.getContext('2d');\n\t\t\t\n\t\t\t    // Smoothing\n\t\t\t    if (context.imageSmoothingEnabled !== undefined) {\n\t\t\t        context.imageSmoothingEnabled = settings.smoothing;\n\t\t\t    } else {\n\t\t\t        context.mozImageSmoothingEnabled = settings.smoothing;\n\t\t\t        context.webkitImageSmoothingEnabled = settings.smoothing;\n\t\t\t        context.msImageSmoothingEnabled = settings.smoothing;\n\t\t\t        context.oImageSmoothingEnabled = settings.smoothing;\n\t\t\t    }\n\t\t\t\n\t\t\t    // Get image data\n\t\t\t    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n\t\t\t    var data = imageData.data;\n\t\t\t\n\t\t\t    var contrastFactor = void 0,\n\t\t\t        brightnessOffset = void 0,\n\t\t\t        gammaCorrection = void 0,\n\t\t\t        shadesOfGrayFactor = void 0;\n\t\t\t\n\t\t\t    if (settings.contrast !== 0) {\n\t\t\t        contrastFactor = 259 * (settings.contrast + 255) / (255 * (259 - settings.contrast));\n\t\t\t    }\n\t\t\t\n\t\t\t    if (settings.brightness !== 0) {\n\t\t\t        brightnessOffset = settings.brightness;\n\t\t\t    }\n\t\t\t\n\t\t\t    if (settings.gamma !== 0) {\n\t\t\t        gammaCorrection = 1 / settings.gamma;\n\t\t\t    }\n\t\t\t\n\t\t\t    // Shades of gray\n\t\t\t    if (settings.shadesOfGray > 1 && settings.shadesOfGray < 256) {\n\t\t\t        shadesOfGrayFactor = 255 / (settings.shadesOfGray - 1);\n\t\t\t    }\n\t\t\t\n\t\t\t    // For each pixel\n\t\t\t    for (var i = 0, il = data.length; i < il; i += 4) {\n\t\t\t        // Apply filters\n\t\t\t        invertColor(data, i, settings.invertColor);\n\t\t\t        brightness(data, i, brightnessOffset);\n\t\t\t        contrast(data, i, contrastFactor);\n\t\t\t        gamma(data, i, gammaCorrection);\n\t\t\t        grayscale(data, i, settings.grayscale, shadesOfGrayFactor);\n\t\t\t    }\n\t\t\t\n\t\t\t    // Write new image data on the context\n\t\t\t    context.putImageData(imageData, 0, 0);\n\t\t\t}\n\t\t\t\n\t\t\t// Exports\n\t\t\texports.canvasFilters = canvasFilters;\n\t\t\texports.default = canvasFilters;\n\t\t\n\t\t/***/ }\n\t\t/******/ ])\n\t\t});\n\t\t;\n\t\t//# sourceMappingURL=lw.canvas-filters.js.map\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=lw.canvas-grid.js.map\n\n/***/ }\n/******/ ])\n});\n;\n\n\n// WEBPACK FOOTER //\n// lw.raster-to-gcode.min.js"," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 2ad52f423536c56f847d","import CanvasGrid from 'lw.canvas-grid'\n\n// RasterToGcode class\nclass RasterToGcode extends CanvasGrid {\n    // Class constructor...\n    constructor(settings) {\n        // Defaults settings\n        settings = Object.assign({\n            ppi: { x: 254, y: 254 }, // Pixel Per Inch (25.4 ppi == 1 ppm)\n\n            toolDiameter: 0.1,      // Tool diameter in millimeters\n            rapidRate   : 1500,     // Rapid rate in mm/min (G0 F value)\n            feedRate    : 500,      // Feed rate in mm/min (G1 F value)\n            rateUnit    : 'mm/min', // Rapid/Feed rate unit [mm/min, mm/sec]\n\n            beamRange: { min: 0, max: 1 },   // Beam power range (Firmware value)\n            beamPower: { min: 0, max: 100 }, // Beam power (S value) as percentage of beamRange\n\n            milling  : false, // EXPERIMENTAL\n            zSafe    : 5,     // Safe Z for fast move\n            zSurface : 0,     // Usinable surface (white pixels)\n            zDepth   : -10,   // Z depth (black pixels)\n            passDepth: 1,     // Pass depth in millimeters\n\n            offsets  : { X: 0, Y: 0 }, // Global coordinates offsets\n            trimLine : true,           // Trim trailing white pixels\n            joinPixel: true,           // Join consecutive pixels with same intensity\n            burnWhite: true,           // [true = G1 S0 | false = G0] on inner white pixels\n            verboseG : false,          // Output verbose GCode (print each commands)\n            diagonal : false,          // Go diagonally (increase the distance between points)\n            overscan : 0,              // Add some extra white space (in millimeters) before and after each line\n\n            precision: { X: 2, Y: 2, S: 4 }, // Number of decimals for each commands\n\n            nonBlocking: true, // Use setTimeout to avoid blocking the UI\n\n            filters: {\n                smoothing   : 0,      // Smoothing the input image ?\n                brightness  : 0,      // Image brightness [-255 to +255]\n                contrast    : 0,      // Image contrast [-255 to +255]\n                gamma       : 0,      // Image gamma correction [0.01 to 7.99]\n                grayscale   : 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n                shadesOfGray: 256,    // Number of shades of gray [2-256]\n                invertColor : false   // Invert color...\n            },\n\n            onProgress       : null, // On progress callbacks\n            onProgressContext: null, // On progress callback context\n\n            onDone       : null, // On done callback\n            onDoneContext: null, // On done callback context\n\n            onAbort       : null, // On abort callback\n            onAbortContext: null  // On abort callback context\n        }, settings || {})\n\n        // Init properties\n        super(settings)\n\n        // Milling settings\n        if (this.milling) {\n            if (this.zSafe < this.zSurface) {\n                throw new Error('\"zSafe\" must be greater to \"zSurface\"')\n            }\n\n            this.passes = Math.abs(Math.floor(this.zDepth / this.passDepth))\n        }\n\n        // Negative beam size ?\n        if (this.toolDiameter <= 0) {\n            throw new Error('\"toolDiameter\" must be positive')\n        }\n\n        // Uniforme ppi\n        if (! this.ppi.x) {\n            this.ppi = { x: this.ppi, y: this.ppi }\n        }\n\n        // Calculate PPM = Pixel Per Millimeters\n        this.ppm = {\n            x: parseFloat((2540 / (this.ppi.x * 100)).toFixed(10)),\n            y: parseFloat((2540 / (this.ppi.y * 100)).toFixed(10))\n        }\n\n        // Calculate scale ratio\n        this.scaleRatio = {\n            x: this.ppm.x / this.toolDiameter,\n            y: this.ppm.y / this.toolDiameter\n        }\n\n        // State...\n        this.running      = false\n        this.gcode        = null\n        this.gcodes       = null\n        this.currentLine  = null\n        this.lastCommands = null\n\n        // Output size in millimeters\n        this.outputSize = { width : 0, height: 0 }\n\n        // G0 command\n        this.G1 = ['G', 1]\n        this.G0 = ['G', this.burnWhite ? 1 : 0]\n\n        // Calculate beam offset\n        this.beamOffset = this.toolDiameter * 1000 / 2000\n\n        // Calculate real beam range\n        this.realBeamRange = {\n            min: this.beamRange.max / 100 * this.beamPower.min,\n            max: this.beamRange.max / 100 * this.beamPower.max\n        }\n\n        // Adjuste feed rate to mm/min\n        if (this.rateUnit === 'mm/sec') {\n            this.feedRate  *= 60\n            this.rapidRate *= 60\n        }\n\n        // Register user callbacks\n        this._registerUserCallbacks(this)\n    }\n\n    // Register user callbacks\n    _registerUserCallbacks(callbacks) {\n        // Register user callbacks\n        callbacks.onProgress && this.on('progress', callbacks.onProgress, callbacks.onProgressContext)\n        callbacks.onAbort && this.on('abort', callbacks.onAbort, callbacks.onAbortContext)\n        callbacks.onDone && this.on('done', callbacks.onDone, callbacks.onDoneContext)\n    }\n\n    // Process image\n    _processImage() {\n        // Call parent method\n        super._processImage()\n\n        // Calculate output size\n        this.outputSize = {\n            width : this.size.width  * (this.toolDiameter * 1000) / 1000,\n            height: this.size.height * (this.toolDiameter * 1000) / 1000\n        }\n    }\n\n    // Abort job\n    abort() {\n        this.running = false\n    }\n\n    // Process image and return gcode string\n    run(settings) {\n        if (this.running) {\n            return\n        }\n        \n        // Reset state\n        this.running      = true\n        this.gcode        = []\n        this.gcodes       = []\n        this.lastCommands = {}\n        this.currentLine  = null\n\n        // Defaults settings\n        settings = settings || {}\n\n        // Register user callbacks\n        this._registerUserCallbacks(settings)\n\n        // Non blocking mode ?\n        let nonBlocking = this.nonBlocking\n\n        if (settings.nonBlocking !== undefined) {\n            nonBlocking = settings.nonBlocking\n        }\n\n        // Add gcode header\n        this._addHeader()\n\n        // Scan type ?\n        if (this.diagonal) {\n            this._scanDiagonally(nonBlocking)\n        }\n        else {\n            this._scanHorizontally(nonBlocking)\n        }\n\n        if (! nonBlocking) {\n            return this.gcode\n        }\n    }\n\n    _addHeader() {\n        // Base headers\n        this.gcode.push(\n            '; Generated by LaserWeb (lw.raster-to-gcode.js)',\n            '; Size       : ' + this.outputSize.width + ' x ' + this.outputSize.height + ' mm',\n            '; PPI        : x: ' + this.ppi.x + ' - y: ' + this.ppi.y,\n            '; PPM        : x: ' + this.ppm.x + ' - y: ' + this.ppm.y,\n            '; Tool diam. : ' + this.toolDiameter + ' mm',\n            '; Rapid rate : ' + this.rapidRate + ' ' + this.rateUnit,\n            '; Feed rate  : ' + this.feedRate + ' ' + this.rateUnit\n        )\n\n        if (this.milling) {\n            this.gcode.push(\n                '; Z safe     : ' + this.zSafe,\n                '; Z surface  : ' + this.zSurface,\n                '; Z depth    : ' + this.zDepth\n            )\n        }\n        else {\n            this.gcode.push(\n                '; Beam range : ' + this.beamRange.min + ' to ' + this.beamRange.max,\n                '; Beam power : ' + this.beamPower.min + ' to ' + this.beamPower.max + ' %'\n            )\n        }\n\n        // Print activated options\n        let options = ['smoothing', 'trimLine', 'joinPixel', 'burnWhite', 'verboseG', 'diagonal']\n\n        for (var i = options.length - 1; i >= 0; i--) {\n            if (! this[options[i]]) {\n                options.splice(i, 1)\n            }\n        }\n\n        if (options.length) {\n            this.gcode.push('; Options    : ' + options.join(', '))\n        }\n\n        // Set feed rates\n        this.gcode.push(\n            '',\n            'G0 F' + this.rapidRate,\n            'G1 F' + this.feedRate,\n            ''\n        )\n    }\n\n    // Map S value to pixel power\n    _mapPixelPower(value) {\n        let range = this.milling ? { min: 0, max: this.zDepth } : this.realBeamRange\n        return value * (range.max - range.min) / 255 + range.min\n    }\n\n    // Compute and return a command, return null if not changed\n    _command(name, value) {\n        // If the value argument is an object\n        if (typeof value === 'object') {\n            // Computed commands line\n            let commands = Array.prototype.slice.call(arguments)\n            let command, line = []\n\n            // for each command\n            for (var i = 0, il = commands.length; i < il; i++) {\n                command = this._command.apply(this, commands[i])\n                command && line.push(command)\n            }\n\n            // Return the line if not empty\n            return line.length ? line.join(' ') : null\n        }\n\n        // Format the value\n        value = value.toFixed(this.precision[name] || 0)\n\n        // If the value was changed or if verbose mode on\n        if (this.verboseG || value !== this.lastCommands[name]) {\n            this.lastCommands[name] = value\n            return name + value\n        }\n\n        // No change\n        return null\n    }\n\n    // Get a pixel power value from the canvas data grid\n    _getPixelPower(x, y, defaultValue) {\n        try {\n            // Reverse Y value since canvas as top/left origin\n            y = this.size.height - y - 1\n\n            // Get pixel info\n            let pixel = this.getPixel(x, y)\n\n            // Reversed gray value [ 0 = white | 255 = black ]\n            return 255 - pixel.gray\n        }\n        catch (error) {\n            if (arguments.length === 3) {\n                return defaultValue\n            }\n            throw error\n        }\n    }\n\n    // Get a point from the current line with real world coordinates\n    _getPoint(index) {\n        // Get the point object from the current line\n        let point = this.currentLine[index]\n\n        // No point\n        if (! point) {\n            return null\n        }\n\n        // Commands\n        point.G = point.s ? ['G', 1] : this.G0\n        point.X = (point.x * this.toolDiameter) + this.offsets.X\n        point.Y = (point.y * this.toolDiameter) + this.offsets.Y\n        point.S = this._mapPixelPower(point.s)\n\n        // Offsets\n        if (this.diagonal) {\n            // Vertical offset\n            point.Y += this.toolDiameter\n\n            // Horizontal offset\n            if (point.first || point.lastWhite) {\n                point.X += this.beamOffset\n                point.Y -= this.beamOffset\n            }\n            else if (point.last || point.lastColored) {\n                point.X -= this.beamOffset\n                point.Y += this.beamOffset\n            }\n        }\n        else {\n            // Vertical offset\n            point.Y += this.beamOffset\n\n            // Horizontal offset\n            if (point.first || point.lastWhite) {\n                point.X += this.beamOffset\n            }\n            else if (point.last || point.lastColored) {\n                point.X -= this.beamOffset\n            }\n        }\n\n        // Return the point\n        return point\n    }\n\n    // Remove all trailing white spaces from the current line\n    _trimCurrentLine() {\n        // Remove white spaces from the left\n        let point = this.currentLine[0]\n\n        while (point && ! point.p) {\n            this.currentLine.shift()\n            point = this.currentLine[0]\n        }\n\n        // Remove white spaces from the right\n        point = this.currentLine[this.currentLine.length - 2]\n\n        while (point && ! point.p) {\n            this.currentLine.pop()\n            point = this.currentLine[this.currentLine.length - 2]\n        }\n\n        // Return the new line length\n        return this.currentLine.length\n    }\n\n    // Join pixel with same power\n    _reduceCurrentLine() {\n        // Line too short to be reduced\n        if (this.currentLine.length < 3) {\n            return this.currentLine.length\n        }\n\n        // Extract all points exept the first one\n        let points = this.currentLine.splice(1)\n\n        // Get current power\n        let power = this.currentLine[0].p\n\n        // For each extracted point\n        for (var point, i = 0, il = points.length - 1; i < il; i++) {\n            // Current point\n            point = points[i]\n\n            // On power change\n            if (power !== point.p) {\n                this.currentLine.push(point)\n            }\n\n            // Update power\n            power = point.p\n        }\n\n        // Add last point\n        this.currentLine.push(points[i])\n    }\n\n    // Add extra white pixels at the ends\n    _overscanCurrentLine(reversed) {\n        // Number of pixels to add on each side\n        let pixels = this.overscan / this.ppm.x\n\n        // Get first/last point\n        let firstPoint = this.currentLine[0]\n        let lastPoint  = this.currentLine[this.currentLine.length - 1]\n\n        // Is last white/colored point ?\n        firstPoint.s && (firstPoint.lastWhite  = true)\n        lastPoint.s  && (lastPoint.lastColored = true)\n\n        // Reversed line ?\n        reversed ? (lastPoint.s = 0) : (firstPoint.s = 0)\n\n        // Create left/right points\n        let rightPoint = { x: lastPoint.x + pixels , y: lastPoint.y , s: 0, p: 0 }\n        let leftPoint  = { x: firstPoint.x - pixels, y: firstPoint.y, s: 0, p: 0 }\n\n        if (this.diagonal) {\n            leftPoint.y  += pixels\n            rightPoint.y -= pixels\n        }\n\n        // Add left/right points to current line\n        this.currentLine.unshift(leftPoint)\n        this.currentLine.push(rightPoint)\n    }\n\n    // Process current line and return an array of GCode text lines\n    _processCurrentLine(reversed) {\n        if (this.milling) {\n            return this._processMillingLine(reversed)\n        }\n\n        return this._processLaserLine(reversed)\n    }\n\n    // Process current line and return an array of GCode text lines\n    _processMillingLine(reversed) {\n        // Skip empty line\n        if (! this._trimCurrentLine()) {\n            return null\n        }\n\n        // Join pixel with same power\n        if (this.joinPixel) {\n            this._reduceCurrentLine()\n        }\n\n        // Mark first and last point on the current line\n        this.currentLine[0].first = true\n        this.currentLine[this.currentLine.length - 1].last = true\n\n        // Reversed line ?\n        if (reversed) {\n            this.currentLine = this.currentLine.reverse()\n        }\n\n        // Point index\n        let point, index = 0\n\n        // Init loop vars...\n        let command, gcode = []\n\n        let addCommand = (...args) => {\n            command = this._command(...args)\n            command && gcode.push(command)\n        }\n\n        // Get first point\n        point = this._getPoint(index)\n\n        let plung = false\n        let Z, zMax\n\n        let pass = (passNum) => {\n            // Move to start of the line\n            addCommand(['G', 0], ['Z', this.zSafe])\n            addCommand(['G', 0], ['X', point.X], ['Y', point.Y])\n            addCommand(['G', 0], ['Z', this.zSurface])\n\n            // For each point on the line\n            while (point) {\n                if (point.S) {\n                    if (plung) {\n                        addCommand(['G', 0], ['Z', this.zSurface])\n                        plung = false\n                    }\n\n                    Z    = point.S\n                    zMax = this.passDepth * passNum\n\n                    // Last pass\n                    if (passNum < this.passes) {\n                        Z = Math.max(Z, -zMax)\n                    }\n\n                    addCommand(['G', 1], ['Z', this.zSurface + Z])\n                    addCommand(['G', 1], ['X', point.X], ['Y', point.Y])\n                }\n                else {\n                    if (plung) {\n                        addCommand(['G', 1], ['Z', this.zSurface])\n                        plung = false\n                    }\n\n                    addCommand(['G', 0], ['Z', this.zSafe])\n                    addCommand(['G', 0], ['X', point.X], ['Y', point.Y])\n                }\n\n                if (point.lastWhite || point.lastColored) {\n                    plung = true\n                }\n\n                // Get next point\n                point = this._getPoint(++index)\n            }\n\n            // Move to Z safe\n            addCommand(['G', 1], ['Z', this.zSurface])\n            addCommand(['G', 0], ['Z', this.zSafe])\n        }\n\n        for (var i = 1; i <= this.passes; i++) {\n            pass(i)\n\n            if (! gcode.length) {\n                break\n            }\n\n            if (this.gcodes.length < i) {\n                this.gcodes.push([])\n            }\n            else {\n                this.gcodes[i - 1].push.apply(this.gcodes[i - 1], gcode)\n            }\n\n            index = 0\n            gcode = []\n            point = this._getPoint(index)\n\n            this.lastCommands = {}\n        }\n\n        // Not sure what to return...\n        return null\n    }\n\n    // Process current line and return an array of GCode text lines\n    _processLaserLine(reversed) {\n        // Trim trailing white spaces ?\n        if (this.trimLine && ! this._trimCurrentLine()) {\n            // Skip empty line\n            return null\n        }\n\n        // Join pixel with same power\n        if (this.joinPixel) {\n            this._reduceCurrentLine()\n        }\n\n        // Overscan ?\n        if (this.overscan) {\n            this._overscanCurrentLine(reversed)\n        }\n\n        // Mark first and last point on the current line\n        this.currentLine[0].first = true\n        this.currentLine[this.currentLine.length - 1].last = true\n\n        // Reversed line ?\n        if (reversed) {\n            this.currentLine = this.currentLine.reverse()\n        }\n\n        // Point index\n        let point, index = 0\n\n        // Init loop vars...\n        let command, gcode = []\n\n        let addCommand = (...args) => {\n            command = this._command(...args)\n            command && gcode.push(command)\n        }\n\n        // Get first point\n        point = this._getPoint(index)\n\n        // Move to start of the line\n        addCommand(this.G0, ['X', point.X], ['Y', point.Y], ['S', 0])\n\n        // For each point on the line\n        while (point) {\n            // Burn to next point\n            addCommand(point.G, ['X', point.X], ['Y', point.Y], ['S', point.S])\n\n            // Get next point\n            point = this._getPoint(++index)\n        }\n\n        // Return gcode commands array\n        if (gcode.length) {\n            return gcode\n        }\n\n        // Empty line\n        return null\n    }\n\n    // Parse horizontally\n    _scanHorizontally(nonBlocking) {\n        // Init loop vars\n        let x = 0, y = 0\n        let s, p, point, gcode\n        let w = this.size.width\n        let h = this.size.height\n\n        let reversed    = false\n        let lastWhite   = false\n        let lastColored = false\n\n        let computeCurrentLine = () => {\n            // Reset current line\n            this.currentLine = []\n\n            // Reset point object\n            point = null\n\n            // For each pixel on the line\n            for (x = 0; x <= w; x++) {\n                // Get pixel power\n                s = p = this._getPixelPower(x, y, p)\n\n                // Is last white/colored pixel\n                lastWhite   = point && ! point.p && p\n                lastColored = point && point.p && ! p\n\n                // Pixel color from last one on normal line\n                if (! reversed && point) {\n                    s = point.p\n                }\n\n                // Create point object\n                point = { x: x, y: y, s: s, p: p }\n\n                // Set last white/colored pixel\n                lastWhite   && (point.lastWhite   = true)\n                lastColored && (point.lastColored = true)\n\n                // Add point to current line\n                this.currentLine.push(point)\n            }\n        }\n\n        let percent     = 0\n        let lastPercent = 0\n\n        let processCurrentLine = () => {\n            // Process pixels line\n            gcode = this._processCurrentLine(reversed)\n\n            // Call progress callback\n            percent = Math.round((y / h) * 100)\n\n            if (percent > lastPercent) {\n                this._onProgress({ gcode, percent })\n            }\n\n            lastPercent = percent\n\n            // Skip empty gcode line\n            if (! gcode) {\n                return\n            }\n\n            // Toggle line state\n            reversed = ! reversed\n\n            // Concat line\n            this.gcode.push.apply(this.gcode, gcode)\n        }\n\n        let processNextLine = () => {\n            // Aborted ?\n            if (! this.running) {\n                return this._onAbort()\n            }\n\n            // Process line...\n            computeCurrentLine()\n            processCurrentLine()\n\n            y++\n\n            if (y < h) {\n                if (nonBlocking) {\n                    setTimeout(processNextLine, 0)\n                }\n                else {\n                    processNextLine()\n                }\n            }\n            else {\n                if (this.milling) {\n                    this.gcodes.forEach(gcode => {\n                        this.gcode.push.apply(this.gcode, gcode)\n                    })\n                }\n\n                this._onDone({ gcode: this.gcode })\n                this.running = false\n            }\n        }\n\n        processNextLine()\n    }\n\n    // Parse diagonally\n    _scanDiagonally(nonBlocking) {\n        // Init loop vars\n        let x = 0, y = 0\n        let s, p, point, gcode\n        let w = this.size.width\n        let h = this.size.height\n\n        let totalLines  = w + h - 1\n        let lineNum     = 0\n        let reversed    = false\n        let lastWhite   = false\n        let lastColored = false\n\n        let computeCurrentLine = (x, y) => {\n            // Reset current line\n            this.currentLine = []\n\n            // Reset point object\n            point = null\n\n            // Increment line num\n            lineNum++\n\n            while(true) {\n                // Y limit reached !\n                if (y < -1 || y == h) {\n                    break\n                }\n\n                // X limit reached !\n                if (x < 0 || x > w) {\n                    break\n                }\n\n                // Get pixel power\n                s = p = this._getPixelPower(x, y, p)\n\n                // Is last white/colored pixel\n                lastWhite   = point && (! point.p && p)\n                lastColored = point && (point.p && ! p)\n\n                // Pixel color from last one on normal line\n                if (! reversed && point) {\n                    s = point.p\n                }\n\n                // Create point object\n                point = { x: x, y: y, s: s, p: p }\n\n                // Set last white/colored pixel\n                lastWhite   && (point.lastWhite   = true)\n                lastColored && (point.lastColored = true)\n\n                // Add the new point\n                this.currentLine.push(point)\n\n                // Next coords\n                x++\n                y--\n            }\n        }\n\n        let percent     = 0\n        let lastPercent = 0\n\n        let processCurrentLine = () => {\n            // Process pixels line\n            gcode = this._processCurrentLine(reversed)\n\n            // Call progress callback\n            percent = Math.round((lineNum / totalLines) * 100)\n\n            if (percent > lastPercent) {\n                this._onProgress({ gcode, percent })\n            }\n\n            lastPercent = percent\n\n            // Skip empty gcode line\n            if (! gcode) {\n                return\n            }\n\n            // Toggle line state\n            reversed = ! reversed\n\n            // Concat line\n            this.gcode.push.apply(this.gcode, gcode)\n        }\n\n        let processNextLine = () => {\n            // Aborted ?\n            if (! this.running) {\n                return this._onAbort()\n            }\n\n            // Process line...\n            computeCurrentLine(x, y)\n            processCurrentLine()\n\n            if (! x) y++\n            else x++\n\n            if (y === h) {\n                x++\n                y--\n            }\n\n            if (y < h && x < w) {\n                if (nonBlocking) {\n                    setTimeout(processNextLine, 0)\n                }\n                else {\n                    processNextLine()\n                }\n            }\n            else {\n                this._onDone({ gcode: this.gcode })\n                this.running = false\n            }\n        }\n\n        processNextLine()\n    }\n\n    _onProgress(event) {\n        //console.log('progress:', event.percent)\n    }\n\n    _onDone(event) {\n        //console.log('done:', event.gcode.length)\n    }\n\n    _onAbort() {\n        //console.log('abort')\n    }\n\n    on(event, callback, context) {\n        let method = '_on' + event[0].toUpperCase() + event.slice(1)\n\n        if (! this[method] || typeof this[method] !== 'function') {\n            throw new Error('Undefined event: ' + event)\n        }\n\n        this[method] = event => callback.call(context || this, event)\n\n        return this\n    }\n\n    // Return the bitmap height-map\n    getHeightMap(settings) {\n        if (this.running) {\n            return\n        }\n\n        // Init loop vars\n        this.running  = true\n        let heightMap = []\n\n        let x = 0\n        let y = 0\n        let w = this.size.width\n        let h = this.size.height\n\n        let percent     = 0\n        let lastPercent = 0\n\n        // Defaults settings\n        settings = settings || {}\n\n        // Register user callbacks\n        this._registerUserCallbacks(settings)\n\n        // Non blocking mode ?\n        let nonBlocking = this.nonBlocking\n\n        if (settings.nonBlocking !== undefined) {\n            nonBlocking = settings.nonBlocking\n        }\n\n        let computeCurrentLine = () => {\n            // Reset current line\n            let pixels = []\n\n            // For each pixel on the line\n            for (x = 0; x < w; x++) {\n                pixels.push(this._mapPixelPower(this._getPixelPower(x, y)))\n            }\n\n            // Call progress callback\n            percent = Math.round((y / h) * 100)\n\n            if (percent > lastPercent) {\n                //onProgress.call(settings.progressContext || this, { pixels, percent })\n                this._onProgress({ pixels, percent })\n            }\n\n            lastPercent = percent\n\n            // Add pixels line\n            heightMap.push(pixels)\n        }\n\n        let processNextLine = () => {\n            // Aborted ?\n            if (! this.running) {\n                return this._onAbort()\n            }\n\n            // Process line...\n            computeCurrentLine()\n\n            y++\n\n            if (y < h) {\n                if (nonBlocking) {\n                    setTimeout(processNextLine, 0)\n                }\n                else {\n                    processNextLine()\n                }\n            }\n            else {\n                //onDone.call(settings.doneContext || this, { heightMap })\n                this._onDone({ heightMap })\n                this.running = false\n            }\n        }\n\n        processNextLine()\n\n        if (! nonBlocking) {\n            return heightMap\n        }\n    }\n}\n\n// Exports\nexport { RasterToGcode }\nexport default RasterToGcode\n\n\n\n// WEBPACK FOOTER //\n// ./raster-to-gcode.js","(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"CanvasGrid\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"CanvasGrid\"] = factory();\n\telse\n\t\troot[\"CanvasGrid\"] = factory();\n})(this, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __webpack_require__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId])\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\texports: {},\n/******/ \t\t\tid: moduleId,\n/******/ \t\t\tloaded: false\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.loaded = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__webpack_require__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__webpack_require__.c = installedModules;\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__webpack_require__.p = \"\";\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __webpack_require__(0);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ function(module, exports, __webpack_require__) {\n\n\tmodule.exports = __webpack_require__(1);\n\n\n/***/ },\n/* 1 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t'use strict';\n\t\n\tObject.defineProperty(exports, \"__esModule\", {\n\t    value: true\n\t});\n\texports.CanvasGrid = undefined;\n\t\n\tvar _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();\n\t\n\tvar _lw = __webpack_require__(2);\n\t\n\tvar _lw2 = _interopRequireDefault(_lw);\n\t\n\tfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\t\n\tfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\t\n\t// CanvasGrid class\n\tvar CanvasGrid = function () {\n\t    // Class constructor...\n\t    function CanvasGrid(settings) {\n\t        _classCallCheck(this, CanvasGrid);\n\t\n\t        // Init properties\n\t        this.cellSize = 1024;\n\t        this.scaleRatio = { x: 1, y: 1 };\n\t        this.filters = {};\n\t\n\t        Object.assign(this, settings || {});\n\t\n\t        if (!this.scaleRatio.x) {\n\t            this.scaleRatio = { x: this.scaleRatio, y: this.scaleRatio };\n\t        }\n\t\n\t        this.size = { width: 0, height: 0, cols: 0, rows: 0 };\n\t        this.file = null;\n\t        this.image = null;\n\t        this.url = null;\n\t        this.canvas = [];\n\t        this.pixels = [];\n\t    }\n\t\n\t    // <input> can be Image, File, URL object or URL string (http://* or data:image/*)\n\t\n\t\n\t    _createClass(CanvasGrid, [{\n\t        key: 'load',\n\t        value: function load(input) {\n\t            // Load File object\n\t            if (input instanceof File) {\n\t                return this.loadFromFile(input);\n\t            }\n\t\n\t            // Load Image object\n\t            if (input instanceof Image) {\n\t                return this.loadFromImage(input);\n\t            }\n\t\n\t            // Load URL object\n\t            if (typeof input === 'string' || input instanceof URL) {\n\t                return this.loadFromURL(input.trim());\n\t            }\n\t\n\t            // Return rejected promise with an Error object\n\t            return Promise.reject(new Error('Unsupported input format.'));\n\t        }\n\t\n\t        // Load image\n\t\n\t    }, {\n\t        key: '_loadImage',\n\t        value: function _loadImage(src, reject, resolve) {\n\t            var _this = this;\n\t\n\t            // Create Image object\n\t            var image = new Image();\n\t\n\t            // Register for load and error events\n\t            image.onload = function (event) {\n\t                _this.loadFromImage(image).then(resolve).catch(reject);\n\t            };\n\t\n\t            image.onerror = function (event) {\n\t                reject(new Error('An error occurred while loading the image : ' + src));\n\t            };\n\t\n\t            // Load the image from File url\n\t            image.src = src;\n\t        }\n\t\n\t        // Load from File object\n\t\n\t    }, {\n\t        key: 'loadFromFile',\n\t        value: function loadFromFile(input) {\n\t            var _this2 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof File)) {\n\t                    reject(new Error('Input param must be a File object.'));\n\t                }\n\t\n\t                // Set input file\n\t                _this2.file = input;\n\t\n\t                // Load image\n\t                _this2._loadImage(URL.createObjectURL(input), reject, resolve);\n\t            });\n\t        }\n\t\n\t        // Load from URL object or string\n\t\n\t    }, {\n\t        key: 'loadFromURL',\n\t        value: function loadFromURL(input) {\n\t            var _this3 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof URL) && typeof input !== 'string') {\n\t                    reject(new Error('Input param must be a URL string or object.'));\n\t                }\n\t\n\t                // Create url object\n\t                var url = input instanceof URL ? input : new URL(input);\n\t\n\t                // Set url\n\t                _this3.url = url;\n\t\n\t                // Load image\n\t                _this3._loadImage(url, reject, resolve);\n\t            });\n\t        }\n\t\n\t        // Load from Image object\n\t\n\t    }, {\n\t        key: 'loadFromImage',\n\t        value: function loadFromImage(input) {\n\t            var _this4 = this;\n\t\n\t            return new Promise(function (resolve, reject) {\n\t                // Bad input type\n\t                if (!(input instanceof Image)) {\n\t                    reject(new Error('Input param must be a Image object.'));\n\t                }\n\t\n\t                // Set input image\n\t                _this4.image = input;\n\t\n\t                // Process image\n\t                _this4._processImage();\n\t\n\t                // Resolve the promise\n\t                resolve(_this4);\n\t            });\n\t        }\n\t    }, {\n\t        key: '_processImage',\n\t        value: function _processImage() {\n\t            // Reset canvas grid\n\t            this.canvas = [];\n\t            this.pixels = [];\n\t\n\t            // Calculate grid size\n\t            var width = Math.round(this.image.width * this.scaleRatio.x);\n\t            var height = Math.round(this.image.height * this.scaleRatio.y);\n\t            var cols = Math.ceil(width / this.cellSize);\n\t            var rows = Math.ceil(height / this.cellSize);\n\t\n\t            this.size = { width: width, height: height, cols: cols, rows: rows };\n\t\n\t            // Create canvas grid\n\t            var line = null;\n\t            var canvas = null;\n\t            var context = null;\n\t\n\t            var x = null; // cols\n\t            var y = null; // rows\n\t            var sx = null; // scaled cols\n\t            var sy = null; // scaled rows\n\t            var sw = null; // scaled width\n\t            var sh = null; // scaled height\n\t\n\t            // For each line\n\t            for (y = 0; y < this.size.rows; y++) {\n\t                // Reset current line\n\t                line = [];\n\t\n\t                // For each column\n\t                for (x = 0; x < this.size.cols; x++) {\n\t                    // Create canvas element\n\t                    canvas = document.createElement('canvas');\n\t\n\t                    // Set canvas size\n\t                    if (x === 0 || x < this.size.cols - 1) {\n\t                        canvas.width = this.size.width < this.cellSize ? this.size.width : this.cellSize;\n\t                    } else {\n\t                        // Get the rest for the last item (except the first one)\n\t                        canvas.width = this.size.width % this.cellSize;\n\t                    }\n\t\n\t                    if (y === 0 || y < this.size.rows - 1) {\n\t                        canvas.height = this.size.height < this.cellSize ? this.size.height : this.cellSize;\n\t                    } else {\n\t                        // Get the rest for the last item (except the first one)\n\t                        canvas.height = this.size.height % this.cellSize;\n\t                    }\n\t\n\t                    // Get canvas 2d context\n\t                    context = canvas.getContext('2d');\n\t\n\t                    // Fill withe background (avoid alpha chanel calculation)\n\t                    context.fillStyle = 'white';\n\t                    context.fillRect(0, 0, canvas.width, canvas.height);\n\t\n\t                    // Draw the part of image in the canvas (scale)\n\t                    sw = canvas.width / this.scaleRatio.x;\n\t                    sh = canvas.height / this.scaleRatio.y;\n\t                    sx = x * this.cellSize / this.scaleRatio.x;\n\t                    sy = y * this.cellSize / this.scaleRatio.y;\n\t\n\t                    context.drawImage(this.image, sx, sy, sw, sh, 0, 0, canvas.width, canvas.height);\n\t\n\t                    // Apply image filters\n\t                    (0, _lw2.default)(canvas, this.filters);\n\t\n\t                    // Add the canvas to current line\n\t                    line.push(canvas);\n\t                }\n\t\n\t                // Add the line to canvas grid\n\t                this.canvas.push(line);\n\t            }\n\t        }\n\t    }, {\n\t        key: 'getPixel',\n\t        value: function getPixel(x, y) {\n\t            // Test coords validity\n\t            x = parseInt(x);\n\t            y = parseInt(y);\n\t\n\t            if (isNaN(x) || isNaN(y)) {\n\t                throw new Error('[x, y] params must be Integer.');\n\t            }\n\t\n\t            // Test coords range\n\t            if (x < 0 || x >= this.size.width) {\n\t                throw new Error('Out of range: x = ' + x + ', max: ' + this.size.width);\n\t            }\n\t\n\t            if (y < 0 || y >= this.size.height) {\n\t                throw new Error('Out of range: y = ' + y + ', max: ' + this.size.height);\n\t            }\n\t\n\t            // Calculate target canvas coords\n\t            var col = parseInt(x / this.cellSize);\n\t            var row = parseInt(y / this.cellSize);\n\t\n\t            // Adjuste x/y values relative to canvas origin\n\t            col && (x -= this.cellSize * col);\n\t            row && (y -= this.cellSize * row);\n\t\n\t            // Get pixel data\n\t            var canvas = this.canvas[row][col];\n\t            var context = canvas.getContext('2d');\n\t            var pixelData = context.getImageData(x, y, 1, 1).data;\n\t\n\t            return {\n\t                color: { r: pixelData[0], g: pixelData[1], b: pixelData[2], a: pixelData[3] },\n\t                gray: (pixelData[0] + pixelData[1] + pixelData[2]) / 3,\n\t                grid: { col: col, row: row },\n\t                coords: { x: x, y: y }\n\t            };\n\t        }\n\t    }]);\n\t\n\t    return CanvasGrid;\n\t}();\n\t\n\t// Exports\n\t\n\t\n\texports.CanvasGrid = CanvasGrid;\n\texports.default = CanvasGrid;\n\n/***/ },\n/* 2 */\n/***/ function(module, exports, __webpack_require__) {\n\n\t(function webpackUniversalModuleDefinition(root, factory) {\n\t\tif(true)\n\t\t\tmodule.exports = factory();\n\t\telse if(typeof define === 'function' && define.amd)\n\t\t\tdefine(\"CanvasFilter\", [], factory);\n\t\telse if(typeof exports === 'object')\n\t\t\texports[\"CanvasFilter\"] = factory();\n\t\telse\n\t\t\troot[\"CanvasFilter\"] = factory();\n\t})(this, function() {\n\treturn /******/ (function(modules) { // webpackBootstrap\n\t/******/ \t// The module cache\n\t/******/ \tvar installedModules = {};\n\t/******/\n\t/******/ \t// The require function\n\t/******/ \tfunction __webpack_require__(moduleId) {\n\t/******/\n\t/******/ \t\t// Check if module is in cache\n\t/******/ \t\tif(installedModules[moduleId])\n\t/******/ \t\t\treturn installedModules[moduleId].exports;\n\t/******/\n\t/******/ \t\t// Create a new module (and put it into the cache)\n\t/******/ \t\tvar module = installedModules[moduleId] = {\n\t/******/ \t\t\texports: {},\n\t/******/ \t\t\tid: moduleId,\n\t/******/ \t\t\tloaded: false\n\t/******/ \t\t};\n\t/******/\n\t/******/ \t\t// Execute the module function\n\t/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\t/******/\n\t/******/ \t\t// Flag the module as loaded\n\t/******/ \t\tmodule.loaded = true;\n\t/******/\n\t/******/ \t\t// Return the exports of the module\n\t/******/ \t\treturn module.exports;\n\t/******/ \t}\n\t/******/\n\t/******/\n\t/******/ \t// expose the modules object (__webpack_modules__)\n\t/******/ \t__webpack_require__.m = modules;\n\t/******/\n\t/******/ \t// expose the module cache\n\t/******/ \t__webpack_require__.c = installedModules;\n\t/******/\n\t/******/ \t// __webpack_public_path__\n\t/******/ \t__webpack_require__.p = \"\";\n\t/******/\n\t/******/ \t// Load entry module and return exports\n\t/******/ \treturn __webpack_require__(0);\n\t/******/ })\n\t/************************************************************************/\n\t/******/ ([\n\t/* 0 */\n\t/***/ function(module, exports, __webpack_require__) {\n\t\n\t\tmodule.exports = __webpack_require__(1);\n\t\n\t\n\t/***/ },\n\t/* 1 */\n\t/***/ function(module, exports) {\n\t\n\t\t'use strict';\n\t\t\n\t\tObject.defineProperty(exports, \"__esModule\", {\n\t\t    value: true\n\t\t});\n\t\t// Grayscale algorithms\n\t\tvar grayscaleAlgorithms = ['none', 'average', 'desaturation', 'decomposition-min', 'decomposition-max', 'luma', 'luma-601', 'luma-709', 'luma-240', 'red-chanel', 'green-chanel', 'blue-chanel'];\n\t\t\n\t\t// Trucate color value in the 0-255 range\n\t\tfunction color(color) {\n\t\t    return color < 0 ? 0 : color > 255 ? 255 : color;\n\t\t}\n\t\t\n\t\t// Filters ...\n\t\tfunction invertColor(data, i, value) {\n\t\t    if (value) {\n\t\t        data[i] = color(255 - data[i]);\n\t\t        data[i + 1] = color(255 - data[i + 1]);\n\t\t        data[i + 2] = color(255 - data[i + 2]);\n\t\t    }\n\t\t}\n\t\t\n\t\tfunction brightness(data, i, value) {\n\t\t    if (value !== undefined) {\n\t\t        data[i] = color(data[i] + value);\n\t\t        data[i + 1] = color(data[i + 1] + value);\n\t\t        data[i + 2] = color(data[i + 2] + value);\n\t\t    }\n\t\t}\n\t\t\n\t\tfunction contrast(data, i, value) {\n\t\t    if (value !== undefined) {\n\t\t        data[i] = color(value * (data[i] - 128) + 128);\n\t\t        data[i + 1] = color(value * (data[i + 1] - 128) + 128);\n\t\t        data[i + 2] = color(value * (data[i + 2] - 128) + 128);\n\t\t    }\n\t\t}\n\t\t\n\t\tfunction gamma(data, i, value) {\n\t\t    if (value !== undefined) {\n\t\t        data[i] = color(Math.exp(Math.log(255 * (data[i] / 255)) * value));\n\t\t        data[i + 1] = color(Math.exp(Math.log(255 * (data[i + 1] / 255)) * value));\n\t\t        data[i + 2] = color(Math.exp(Math.log(255 * (data[i + 2] / 255)) * value));\n\t\t    }\n\t\t}\n\t\t\n\t\tfunction grayscale(data, i, algorithm, shades) {\n\t\t    // Graysale\n\t\t    // http://www.tannerhelland.com/3643/grayscale-image-algorithm-vb6/\n\t\t\n\t\t    // Unsupported algorithm\n\t\t    if (grayscaleAlgorithms.indexOf(algorithm) === -1) {\n\t\t        throw new Error('Unsupported grayscale algorithm: ' + algorithm);\n\t\t    }\n\t\t\n\t\t    // None\n\t\t    if (algorithm === 'none') {\n\t\t        return null;\n\t\t    }\n\t\t\n\t\t    // Get Red/Green/Blue values\n\t\t    var gray = void 0;\n\t\t    var r = data[i];\n\t\t    var g = data[i + 1];\n\t\t    var b = data[i + 2];\n\t\t\n\t\t    switch (algorithm) {\n\t\t        case 'average':\n\t\t            gray = (r + g + b) / 3;\n\t\t            break;\n\t\t\n\t\t        case 'luma':\n\t\t            // Default\n\t\t            gray = r * 0.3 + g * 0.59 + b * 0.11;\n\t\t            break;\n\t\t\n\t\t        case 'luma-601':\n\t\t            // CCIR-601\n\t\t            gray = r * 0.299 + g * 0.587 + b * 0.114;\n\t\t            break;\n\t\t\n\t\t        case 'luma-709':\n\t\t            // ITU-R-709\n\t\t            gray = r * 0.2126 + g * 0.7152 + b * 0.0722;\n\t\t            break;\n\t\t\n\t\t        case 'luma-240':\n\t\t            // SMPTE-240M\n\t\t            gray = r * 0.212 + g * 0.701 + b * 0.087;\n\t\t            break;\n\t\t\n\t\t        case 'desaturation':\n\t\t            gray = (Math.max(r, g, b) + Math.min(r, g, b)) / 2;\n\t\t            break;\n\t\t\n\t\t        case 'decomposition-min':\n\t\t            gray = Math.min(r, g, b);\n\t\t            break;\n\t\t\n\t\t        case 'decomposition-max':\n\t\t            gray = Math.max(r, g, b);\n\t\t            break;\n\t\t\n\t\t        case 'red-chanel':\n\t\t            gray = r;\n\t\t            break;\n\t\t\n\t\t        case 'green-chanel':\n\t\t            gray = g;\n\t\t            break;\n\t\t\n\t\t        case 'blue-chanel':\n\t\t            gray = b;\n\t\t            break;\n\t\t    }\n\t\t\n\t\t    // Shades of gray\n\t\t    if (shades !== undefined) {\n\t\t        gray = parseInt(gray / shades) * shades;\n\t\t    }\n\t\t\n\t\t    // Force integer\n\t\t    gray = parseInt(gray);\n\t\t\n\t\t    // Set new r/g/b values\n\t\t    data[i] = color(gray);\n\t\t    data[i + 1] = color(gray);\n\t\t    data[i + 2] = color(gray);\n\t\t}\n\t\t\n\t\t// Apply filters on provided canvas\n\t\tfunction canvasFilters(canvas, settings) {\n\t\t    settings = Object.assign({}, {\n\t\t        smoothing: false, // Smoothing [true|fale]\n\t\t        brightness: 0, // Image brightness [-255 to +255]\n\t\t        contrast: 0, // Image contrast [-255 to +255]\n\t\t        gamma: 0, // Image gamma correction [0.01 to 7.99]\n\t\t        grayscale: 'none', // Graysale algorithm [average, luma, luma-601, luma-709, luma-240, desaturation, decomposition-[min|max], [red|green|blue]-chanel]\n\t\t        shadesOfGray: 256, // Number of shades of gray [2-256]\n\t\t        invertColor: false // Invert color...\n\t\t    }, settings || {});\n\t\t\n\t\t    // Get canvas 2d context\n\t\t    var context = canvas.getContext('2d');\n\t\t\n\t\t    // Smoothing\n\t\t    if (context.imageSmoothingEnabled !== undefined) {\n\t\t        context.imageSmoothingEnabled = settings.smoothing;\n\t\t    } else {\n\t\t        context.mozImageSmoothingEnabled = settings.smoothing;\n\t\t        context.webkitImageSmoothingEnabled = settings.smoothing;\n\t\t        context.msImageSmoothingEnabled = settings.smoothing;\n\t\t        context.oImageSmoothingEnabled = settings.smoothing;\n\t\t    }\n\t\t\n\t\t    // Get image data\n\t\t    var imageData = context.getImageData(0, 0, canvas.width, canvas.height);\n\t\t    var data = imageData.data;\n\t\t\n\t\t    var contrastFactor = void 0,\n\t\t        brightnessOffset = void 0,\n\t\t        gammaCorrection = void 0,\n\t\t        shadesOfGrayFactor = void 0;\n\t\t\n\t\t    if (settings.contrast !== 0) {\n\t\t        contrastFactor = 259 * (settings.contrast + 255) / (255 * (259 - settings.contrast));\n\t\t    }\n\t\t\n\t\t    if (settings.brightness !== 0) {\n\t\t        brightnessOffset = settings.brightness;\n\t\t    }\n\t\t\n\t\t    if (settings.gamma !== 0) {\n\t\t        gammaCorrection = 1 / settings.gamma;\n\t\t    }\n\t\t\n\t\t    // Shades of gray\n\t\t    if (settings.shadesOfGray > 1 && settings.shadesOfGray < 256) {\n\t\t        shadesOfGrayFactor = 255 / (settings.shadesOfGray - 1);\n\t\t    }\n\t\t\n\t\t    // For each pixel\n\t\t    for (var i = 0, il = data.length; i < il; i += 4) {\n\t\t        // Apply filters\n\t\t        invertColor(data, i, settings.invertColor);\n\t\t        brightness(data, i, brightnessOffset);\n\t\t        contrast(data, i, contrastFactor);\n\t\t        gamma(data, i, gammaCorrection);\n\t\t        grayscale(data, i, settings.grayscale, shadesOfGrayFactor);\n\t\t    }\n\t\t\n\t\t    // Write new image data on the context\n\t\t    context.putImageData(imageData, 0, 0);\n\t\t}\n\t\t\n\t\t// Exports\n\t\texports.canvasFilters = canvasFilters;\n\t\texports.default = canvasFilters;\n\t\n\t/***/ }\n\t/******/ ])\n\t});\n\t;\n\t//# sourceMappingURL=lw.canvas-filters.js.map\n\n/***/ }\n/******/ ])\n});\n;\n//# sourceMappingURL=lw.canvas-grid.js.map\n\n\n//////////////////\n// WEBPACK FOOTER\n// ../~/lw.canvas-grid/dist/lw.canvas-grid.js\n// module id = 2\n// module chunks = 0"],"sourceRoot":""}